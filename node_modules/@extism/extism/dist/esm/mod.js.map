{
  "version": 3,
  "sources": ["../../node_modules/balanced-match/index.js", "../../node_modules/brace-expansion/index.js", "../../src/polyfills/node-capabilities.ts", "../../src/interfaces.ts", "../../src/manifest.ts", "../../src/polyfills/response-to-module.ts", "../../src/call-context.ts", "../../src/polyfills/node-wasi.ts", "../../node_modules/minimatch/src/index.ts", "../../node_modules/minimatch/src/assert-valid-pattern.ts", "../../node_modules/minimatch/src/brace-expressions.ts", "../../node_modules/minimatch/src/unescape.ts", "../../node_modules/minimatch/src/ast.ts", "../../node_modules/minimatch/src/escape.ts", "../../src/polyfills/node-minimatch.ts", "../../src/http-context.ts", "../../src/foreground-plugin.ts", "../worker/node/worker-url.ts", "../../src/background-plugin.ts", "../../src/mod.ts"],
  "sourcesContent": ["'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "import type { Capabilities } from '../interfaces.ts';\n\nconst WebAssembly = globalThis.WebAssembly || {};\n\nexport const CAPABILITIES: Capabilities = {\n  supportsJSPromiseInterface:\n    typeof (WebAssembly as any).Suspending === 'function' && typeof (WebAssembly as any).promising === 'function',\n\n  // When false, shared buffers have to be copied to an array\n  // buffer before passing to Text{En,De}coding()\n  allowSharedBufferCodec: false,\n\n  // Whether or not the manifest supports the \"path:\" key.\n  manifestSupportsPaths: true,\n\n  // Whether or not cross-origin checks are enforced on this platform.\n  crossOriginChecksEnforced: false,\n\n  fsAccess: true,\n\n  hasWorkerCapability: true,\n\n  supportsWasiPreview1: true,\n\n  supportsTimeouts: true,\n\n  extismStdoutEnvVarSet: Boolean(process.env.EXTISM_ENABLE_WASI_OUTPUT),\n};\n", "import { CallContext } from './call-context.ts';\n\n/**\n * {@link Plugin} Config\n */\nexport interface PluginConfigLike {\n  [key: string]: string;\n}\n\n/**\n * `PluginOutput` is a view around some memory exposed by the plugin. Typically\n * returned by {@link Plugin#call | `plugin.call()`} or {@link CallContext#read\n * | `callContext.read()`}. It implements the read side of\n * [`DataView`](https://mdn.io/dataview) along with methods for reading string\n * and JSON data out of the backing buffer.\n */\nexport class PluginOutput extends DataView {\n  static #decoder = new TextDecoder();\n  #bytes: Uint8Array | null = null;\n\n  /** @hidden */\n  constructor(buffer: ArrayBufferLike) {\n    super(buffer);\n  }\n\n  json(): any {\n    return JSON.parse(this.string());\n  }\n\n  arrayBuffer(): ArrayBufferLike {\n    return this.buffer;\n  }\n\n  text(): string {\n    return this.string();\n  }\n\n  /** @hidden */\n  string(): string {\n    return PluginOutput.#decoder.decode(this.buffer);\n  }\n\n  bytes(): Uint8Array {\n    this.#bytes ??= new Uint8Array(this.buffer);\n    return this.#bytes;\n  }\n\n  override setInt8(_byteOffset: number, _value: number): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setInt16(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setInt32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setUint8(_byteOffset: number, _value: number): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setUint16(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setUint32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setFloat32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setFloat64(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setBigInt64(_byteOffset: number, _value: bigint, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  override setBigUint64(_byteOffset: number, _value: bigint, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n}\n\nexport type PluginConfig = Record<string, string>;\n\nexport interface Plugin {\n  /**\n   * Check if a function exists in the WebAssembly module.\n   *\n   * @param {string} funcName The function's name.\n   * @returns {Promise<boolean>} true if the function exists, otherwise false\n   */\n  functionExists(funcName: string): Promise<boolean>;\n  close(): Promise<void>;\n\n  /**\n   * Call a specific function from the WebAssembly module with provided input.\n   *\n   * @param {string} funcName The name of the function to call\n   * @param {Uint8Array | string} input The input to pass to the function\n   * @param {T} hostContext Per-call context to make available to host functions\n   * @returns {Promise<PluginOutput | null>} The result from the function call\n   */\n  call<T>(funcName: string, input?: string | number | Uint8Array, hostContext?: T): Promise<PluginOutput | null>;\n  getExports(): Promise<WebAssembly.ModuleExportDescriptor[]>;\n  getImports(): Promise<WebAssembly.ModuleImportDescriptor[]>;\n  getInstance(): Promise<WebAssembly.Instance>;\n\n  /**\n   * Whether the plugin is currently processing a call.\n   */\n  isActive(): boolean;\n\n  /**\n   * Reset Plugin memory. If called while the plugin is {@link Plugin#isActive|actively executing}, memory will not be reset.\n   *\n   * @returns {Promise<boolean>} Whether or not the reset was successful.\n   */\n  reset(): Promise<boolean>;\n}\n\n/**\n * Arguments to be passed to `node:worker_threads.Worker` when `runInWorker: true`.\n */\nexport interface NodeWorkerArgs {\n  name?: string;\n  execArgv?: string[];\n  argv?: string[];\n  env?: Record<string, string>;\n  resourceLimits?: {\n    maxOldGenerationSizeMb?: number;\n    maxYoungGenerationSizeMb?: number;\n    codeRangeSizeMb?: number;\n    stackSizeMb?: number;\n  };\n  [k: string]: any;\n}\n\n/**\n * Options for initializing an Extism plugin.\n */\nexport interface ExtismPluginOptions {\n  /**\n   * Whether or not to enable WASI preview 1.\n   */\n  useWasi?: boolean;\n\n  /**\n   * Whether or not to run the Wasm module in a Worker thread. Requires\n   * {@link Capabilities#hasWorkerCapability | `CAPABILITIES.hasWorkerCapability`} to\n   * be true. Defaults to false.\n   *\n   * This feature is marked experimental as we work out [a bug](https://github.com/extism/js-sdk/issues/46).\n   *\n   * @experimental\n   */\n  runInWorker?: boolean;\n\n  /**\n   * A logger implementation. Must provide `trace`, `info`, `debug`, `warn`, and `error` methods.\n   */\n  logger?: Console;\n\n  /**\n   * The log level to use.\n   */\n  logLevel?: LogLevel;\n\n  /**\n   * A map of namespaces to function names to host functions.\n   *\n   * ```js\n   * const functions = {\n   *   'my_great_namespace': {\n   *     'my_func': (callContext: CallContext, input: bigint) => {\n   *       const output = callContext.read(input);\n   *       if (output !== null) {\n   *         console.log(output.string());\n   *       }\n   *     }\n   *   }\n   * }\n   * ```\n   */\n  functions?:\n    | {\n        [key: string]: {\n          [key: string]: (callContext: CallContext, ...args: any[]) => any;\n        };\n      }\n    | undefined;\n  allowedPaths?: { [key: string]: string } | undefined;\n\n  /**\n   * A list of allowed hostnames. Wildcard subdomains are supported via `*`.\n   *\n   * Requires the plugin to run in a worker using `runInWorker: true`.\n   *\n   * @example\n   * ```ts\n   * await createPlugin('path/to/some/wasm', {\n   *   runInWorker: true,\n   *   allowedHosts: ['*.example.com', 'www.dylibso.com']\n   * })\n   * ```\n   */\n  allowedHosts?: string[] | undefined;\n\n  memory?: MemoryOptions;\n\n  timeoutMs?: number | null;\n\n  /**\n   * Whether WASI stdout should be forwarded to the host.\n   *\n   * Overrides the `EXTISM_ENABLE_WASI_OUTPUT` environment variable.\n   */\n  enableWasiOutput?: boolean;\n  config?: PluginConfigLike;\n  fetch?: typeof fetch;\n  sharedArrayBufferSize?: number;\n\n  /**\n   * Determines whether or not HTTP response headers should be exposed to plugins,\n   * when set to `true`, `extism:host/env::http_headers` will return the response\n   *  headers for HTTP requests made using `extism:host/env::http_request`\n   */\n  allowHttpResponseHeaders?: boolean;\n\n  /**\n   * Arguments to pass to the `node:worker_threads.Worker` instance when `runInWorker: true`.\n   *\n   * This is particularly useful for changing `process.execArgv`, which controls certain startup\n   * behaviors in node (`--import`, `--require`, warnings.)\n   *\n   * If not set, defaults to removing the current `execArgv` and disabling node warnings.\n   */\n  nodeWorkerArgs?: NodeWorkerArgs;\n}\n\nexport type MemoryOptions = {\n  /**\n   * Maximum number of pages to allocate for the WebAssembly memory. Each page is 64KB.\n   */\n  maxPages?: number | undefined;\n\n  /**\n   * Maximum number of bytes to read from an HTTP response.\n   */\n  maxHttpResponseBytes?: number | undefined;\n\n  /**\n   * Maximum number of bytes to allocate for plugin Vars.\n   */\n  maxVarBytes?: number | undefined;\n};\n\ntype CamelToSnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? '_' : ''}${Lowercase<T>}${CamelToSnakeCase<U>}`\n  : S;\n\ntype SnakeCase<T extends Record<string, any>> = {\n  [K in keyof T as CamelToSnakeCase<K & string>]: T[K];\n};\n\nexport interface NativeManifestOptions\n  extends Pick<ExtismPluginOptions, 'allowedPaths' | 'allowedHosts' | 'memory' | 'config' | 'timeoutMs'> {}\n/**\n * The subset of {@link ExtismPluginOptions} attributes available for configuration via\n * a {@link Manifest}. If an attribute is specified at both the {@link ExtismPluginOptions} and\n * `ManifestOptions` level, the plugin option will take precedence.\n */\nexport type ManifestOptions = NativeManifestOptions & SnakeCase<NativeManifestOptions>;\n\nexport interface InternalConfig extends Required<NativeManifestOptions> {\n  logger: Console;\n  logLevel: LogLevelPriority;\n  enableWasiOutput: boolean;\n  functions: { [namespace: string]: { [func: string]: any } };\n  fetch: typeof fetch;\n  wasiEnabled: boolean;\n  sharedArrayBufferSize: number;\n  allowHttpResponseHeaders: boolean;\n  nodeWorkerArgs: NodeWorkerArgs;\n}\n\nexport interface InternalWasi {\n  importObject(): Promise<Record<string, WebAssembly.ImportValue>>;\n  initialize(instance: WebAssembly.Instance): Promise<void>;\n  close(): Promise<void>;\n}\n\n/**\n * Represents the raw bytes of a WASM file loaded into memory\n *\n * @category Manifests\n */\nexport interface ManifestWasmData {\n  data: Uint8Array;\n}\n\n/**\n * Represents a url to a WASM module\n */\nexport interface ManifestWasmUrl {\n  url: URL | string;\n}\n\n/**\n * Represents a path to a WASM module\n */\nexport interface ManifestWasmPath {\n  path: string;\n}\n\n/**\n * Represents a WASM module as a response\n */\nexport interface ManifestWasmResponse {\n  response: Response;\n}\n\n/**\n * Represents a WASM module as a response\n */\nexport interface ManifestWasmModule {\n  module: WebAssembly.Module;\n}\n\n/**\n * The WASM to load as bytes, a path, a fetch `Response`, a `WebAssembly.Module`, or a url\n *\n * @property name The name of the Wasm module. Used when disambiguating {@link Plugin#call | `Plugin#call`} targets when the\n * plugin embeds multiple Wasm modules.\n *\n * @property hash The expected SHA-256 hash of the associated Wasm module data. {@link createPlugin} validates incoming Wasm against\n * provided hashes. If running on Node v18, `node` must be invoked using the `--experimental-global-webcrypto` flag.\n *\n * \u26A0\uFE0F `module` cannot be used in conjunction with `hash`: the Web Platform does not currently provide a way to get source\n * bytes from a `WebAssembly.Module` in order to hash.\n */\nexport type ManifestWasm = (\n  | ManifestWasmUrl\n  | ManifestWasmData\n  | ManifestWasmPath\n  | ManifestWasmResponse\n  | ManifestWasmModule\n) & {\n  name?: string;\n  hash?: string;\n};\n\n/**\n * The manifest which describes the {@link Plugin} code and runtime constraints. This is passed to {@link createPlugin}\n *\n * ```js\n * let manifest = {\n *   wasm: [{name: 'my-wasm', url: 'http://example.com/path/to/wasm'}],\n *   config: {\n *     'greeting': 'hello' // these variables will be available via `extism_get_var` in plugins\n *   }\n * }\n * ```\n *\n * Every member of `.wasm` is expected to be an instance of {@link ManifestWasm}.\n *\n * @see [Extism](https://extism.org/) > [Concepts](https://extism.org/docs/category/concepts) > [Manifest](https://extism.org/docs/concepts/manifest)\n */\nexport interface Manifest extends ManifestOptions {\n  wasm: Array<ManifestWasm>;\n}\n\n/**\n * Any type that can be converted into an Extism {@link Manifest}.\n * - `object` instances that implement {@link Manifest} are validated.\n * - `ArrayBuffer` instances are converted into {@link Manifest}s with a single {@link ManifestWasmData} member.\n * - `URL` instances are fetched and their responses interpreted according to their `content-type` response header. `application/wasm` and `application/octet-stream` items\n *   are treated as {@link ManifestWasmData} items; `application/json` and `text/json` are treated as JSON-encoded {@link Manifest}s.\n * - `string` instances that start with `http://`, `https://`, or `file://` are treated as URLs.\n * - `string` instances that start with `{` treated as JSON-encoded {@link Manifest}s.\n * - All other `string` instances are treated as {@link ManifestWasmPath}.\n *\n * ```js\n * let manifest = {\n *   wasm: [{name: 'my-wasm', url: 'http://example.com/path/to/wasm'}],\n *   config: {\n *     'greeting': 'hello' // these variables will be available via `extism_get_var` in plugins\n *   }\n * }\n *\n * let manifest = '{\"wasm\": {\"url\": \"https://example.com\"}}'\n * let manifest = 'path/to/file.wasm'\n * let manifest = new ArrayBuffer()\n * ```\n *\n * @throws [TypeError](https://mdn.io/TypeError) when `URL` parameters don't resolve to a known `content-type`\n * @throws [TypeError](https://mdn.io/TypeError) when the resulting {@link Manifest} does not contain a `wasm` member with valid {@link ManifestWasm} items.\n *\n * @see [Extism](https://extism.org/) > [Concepts](https://extism.org/docs/category/concepts) > [Manifest](https://extism.org/docs/concepts/manifest)\n */\nexport type ManifestLike = Manifest | Response | WebAssembly.Module | ArrayBuffer | string | URL;\n\nexport interface Capabilities {\n  /**\n   * Whether or not the environment supports [JSPI](https://github.com/WebAssembly/js-promise-integration/blob/main/proposals/js-promise-integration/Overview.md).\n   *\n   * If supported, host functions may be asynchronous without running the plugin with `runInWorker: true`.\n   *\n   * - \u2705 node 23+\n   * - \u274C deno\n   * - \u274C bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  supportsJSPromiseInterface: boolean;\n\n  /**\n   * Whether or not the environment allows SharedArrayBuffers to be passed to `TextDecoder.decode` and `TextEncoder.encodeInto` directly\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  allowSharedBufferCodec: boolean;\n\n  /**\n   * Whether or not {@link ManifestWasm} items support the \"path:\" key.\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  manifestSupportsPaths: boolean;\n\n  /**\n   * Whether or not cross-origin checks are enforced for outgoing HTTP requests on this platform.\n   *\n   * - \u274C node\n   * - \u274C deno\n   * - \u274C bun\n   * - \u2705 firefox\n   * - \u2705 chrome\n   * - \u2705 webkit\n   */\n  crossOriginChecksEnforced: boolean;\n\n  /**\n   * Whether or not the host environment has access to a filesystem.\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  fsAccess: boolean;\n\n  /**\n   * Whether or not the host environment supports moving Wasm plugin workloads to a worker. This requires\n   * SharedArrayBuffer support, which requires `window.crossOriginIsolated` to be true in browsers.\n   *\n   * @see [`crossOriginalIsolated` on MDN](https://mdn.io/crossOriginIsolated)\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \uD83D\uDD12 firefox\n   * - \uD83D\uDD12 chrome\n   * - \uD83D\uDD12 webkit\n   */\n  hasWorkerCapability: boolean;\n\n  /**\n   * Whether or not the host environment supports WASI preview 1.\n   *\n   * @see [`WASI`](https://wasi.dev/) and [`WASI Preview 1`](https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md)\n   *\n   * - \u2705 node (via [`node:wasi`](https://nodejs.org/api/wasi.html))\n   * - \u2705 deno (via [`deno.land/std/wasi/snapshot_preview1`](https://deno.land/std@0.200.0/wasi/snapshot_preview1.ts))\n   * - \u274C bun\n   * - \u2705 firefox (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   * - \u2705 chrome (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   * - \u2705 webkit (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   */\n  supportsWasiPreview1: boolean;\n\n  /**\n   * Whether or not the host environment supports timeouts.\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u274C bun (Exhibits strange behavior when await'ing `worker.terminate()`.)\n   * - \u2705 firefox\n   * - \u2705 chrome\n   * - \u2705 webkit\n   */\n  supportsTimeouts: boolean;\n\n  /**\n   * Whether or not the `EXTISM_ENABLE_WASI_OUTPUT` environment variable has been set.\n   *\n   * This value is consulted whenever {@link ExtismPluginOptions#enableWasiOutput} is omitted.\n   */\n  extismStdoutEnvVarSet: boolean;\n}\n\nexport const SAB_BASE_OFFSET = 4;\n\nexport enum SharedArrayBufferSection {\n  End = 0xff,\n  RetI64 = 1,\n  RetF64 = 2,\n  RetVoid = 3,\n  Block = 4,\n}\n\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nexport function logLevelToPriority(level: LogLevel): LogLevelPriority {\n  switch (level) {\n    case 'trace':\n      return 0;\n    case 'debug':\n      return 1;\n    case 'info':\n      return 2;\n    case 'warn':\n      return 3;\n    case 'error':\n      return 4;\n    case 'silent':\n      return 0x7fffffff;\n    default:\n      throw new TypeError(\n        `unrecognized log level \"${level}\"; expected one of \"trace\", \"debug\", \"info\", \"warn\", \"error\", \"silent\"`,\n      );\n  }\n}\n\nexport type LogLevelPriority = 0 | 1 | 2 | 3 | 4 | 0x7fffffff;\n\nexport function priorityToLogLevel(level: LogLevelPriority): LogLevel {\n  switch (level) {\n    case 0:\n      return 'trace';\n    case 1:\n      return 'debug';\n    case 2:\n      return 'info';\n    case 3:\n      return 'warn';\n    case 4:\n      return 'error';\n    case 0x7fffffff:\n      return 'silent';\n    default:\n      throw new TypeError(\n        `unrecognized log level \"${level}\"; expected one of \"trace\", \"debug\", \"info\", \"warn\", \"error\", \"silent\"`,\n      );\n  }\n}\n", "import type {\n  Manifest,\n  ManifestWasmUrl,\n  ManifestWasmData,\n  ManifestWasmPath,\n  ManifestWasmResponse,\n  ManifestWasmModule,\n  ManifestLike,\n  ManifestOptions,\n} from './interfaces.ts';\nimport { readFile } from './polyfills/node-fs.ts';\nimport { responseToModule } from './polyfills/response-to-module.ts';\n\nasync function _populateWasmField(candidate: ManifestLike, _fetch: typeof fetch): Promise<ManifestLike> {\n  if (candidate instanceof ArrayBuffer) {\n    return { wasm: [{ data: new Uint8Array(candidate as ArrayBuffer) }] };\n  }\n\n  if (candidate instanceof WebAssembly.Module) {\n    return { wasm: [{ module: candidate as WebAssembly.Module }] };\n  }\n\n  if (typeof candidate === 'string') {\n    if (candidate.search(/^\\s*\\{/g) === 0) {\n      return parseManifestFromJson(candidate);\n    }\n\n    if (candidate.search(/^(https?|file):\\/\\//) !== 0) {\n      return { wasm: [{ path: candidate }] };\n    }\n\n    candidate = new URL(candidate);\n  }\n\n  if (candidate instanceof Response || candidate?.constructor?.name === 'Response') {\n    const response: Response = candidate as Response;\n    const contentType = response.headers.get('content-type') || 'application/octet-stream';\n\n    switch (contentType.split(';')[0]) {\n      case 'application/octet-stream':\n      case 'application/wasm':\n        return { wasm: [{ response }] };\n      case 'application/json':\n      case 'text/json':\n        return _populateWasmField(parseManifestFromJson(await response.text()), _fetch);\n      default:\n        throw new TypeError(\n          `While processing manifest URL \"${response.url}\"; expected content-type of \"text/json\", \"application/json\", \"application/octet-stream\", or \"application/wasm\"; got \"${contentType}\" after stripping off charset.`,\n        );\n    }\n  }\n\n  if (candidate instanceof URL) {\n    return _populateWasmField(await _fetch(candidate, { redirect: 'follow' }), _fetch);\n  }\n\n  if (!('wasm' in candidate)) {\n    throw new TypeError('Expected \"wasm\" key in manifest');\n  }\n\n  if (!Array.isArray(candidate.wasm)) {\n    throw new TypeError('Expected \"manifest.wasm\" to be array');\n  }\n\n  const badItemIdx = candidate.wasm.findIndex(\n    (item) =>\n      !('data' in item) && !('url' in item) && !('path' in item) && !('module' in item) && !('response' in item),\n  );\n  if (badItemIdx > -1) {\n    throw new TypeError(\n      `Expected every item in \"manifest.wasm\" to include either a \"data\", \"url\", or \"path\" key; got bad item at index ${badItemIdx}`,\n    );\n  }\n\n  return { ...(candidate as Manifest) };\n}\n\nfunction parseManifestFromJson(json: string): Manifest {\n  const parsed = JSON.parse(json);\n\n  return {\n    wasm: parsed.wasm,\n    timeoutMs: parsed.timeoutMs ?? parsed.timeout_ms,\n    allowedPaths: parsed.allowedPaths ?? parsed.allowed_paths,\n    allowedHosts: parsed.allowedHosts ?? parsed.allowed_hosts,\n    config: parsed.config,\n    ...(parsed.memory\n      ? {\n          maxHttpResponseBytes: parsed.memory.maxHttpResponseBytes ?? parsed.memory.max_http_response_bytes,\n          maxPages: parsed.memory.maxPages ?? parsed.memory.max_pages,\n          maxVarBytes: parsed.memory.maxVarBytes ?? parsed.memory.max_var_bytes,\n        }\n      : {}),\n  };\n}\n\nasync function intoManifest(candidate: ManifestLike, _fetch: typeof fetch = fetch): Promise<Manifest> {\n  const manifest = (await _populateWasmField(candidate, _fetch)) as Manifest;\n  manifest.config ??= {};\n  return manifest;\n}\n\nexport async function toWasmModuleData(\n  input: ManifestLike,\n  _fetch: typeof fetch,\n): Promise<[ManifestOptions, string[], WebAssembly.Module[]]> {\n  const names: string[] = [];\n\n  const manifest = await intoManifest(input, _fetch);\n  const manifestOpts: ManifestOptions = {\n    allowedPaths: manifest.allowedPaths,\n    allowedHosts: manifest.allowedHosts,\n    config: manifest.config,\n    memory: manifest.memory,\n  };\n\n  const manifestsWasm = await Promise.all(\n    manifest.wasm.map(async (item, idx, all) => {\n      let module: WebAssembly.Module;\n      let buffer: ArrayBuffer | undefined;\n      if ((item as ManifestWasmData).data) {\n        const data = (item as ManifestWasmData).data;\n        buffer = data.buffer ? data.buffer : data;\n        module = await WebAssembly.compile(data);\n      } else if ((item as ManifestWasmPath).path) {\n        const path = (item as ManifestWasmPath).path;\n        const data = await readFile(path);\n        buffer = data.buffer as ArrayBuffer;\n        module = await WebAssembly.compile(data);\n      } else if ((item as ManifestWasmUrl).url) {\n        const response = await _fetch((item as ManifestWasmUrl).url, {\n          headers: {\n            accept: 'application/wasm;q=0.9,application/octet-stream;q=0.8',\n          },\n        });\n        const result = await responseToModule(response, Boolean(item.hash));\n        buffer = result.data;\n        module = result.module;\n      } else if ((item as ManifestWasmResponse).response) {\n        const result = await responseToModule((item as ManifestWasmResponse).response, Boolean(item.hash));\n        buffer = result.data;\n        module = result.module;\n      } else if ((item as ManifestWasmModule).module) {\n        (<any>names[idx]) = item.name ?? String(idx);\n        module = (item as ManifestWasmModule).module;\n      } else {\n        throw new Error(\n          `Unrecognized wasm item at index ${idx}. Keys include: \"${Object.keys(item).sort().join(',')}\"`,\n        );\n      }\n\n      let potentialName = String(idx);\n      if (item.hash) {\n        if (!buffer) {\n          throw new Error('Item specified a hash but WebAssembly.Module source data is unavailable for hashing');\n        }\n\n        const hashBuffer = new Uint8Array(await crypto.subtle.digest('SHA-256', buffer));\n        const checkBuffer = new Uint8Array(32);\n        let eq = true;\n        for (let i = 0; i < 32; ++i) {\n          checkBuffer[i] = parseInt(item.hash.slice(i << 1, (i << 1) + 2), 16);\n          // do not exit early: we want to do a constant time comparison\n          eq = eq && checkBuffer[i] === hashBuffer[i];\n        }\n        const hashAsString = () => [...hashBuffer].map((xs) => xs.toString(16).padStart(2, '0')).join('');\n\n        if (!eq) {\n          throw new Error(`Plugin error: hash mismatch. Expected: ${item.hash}. Actual: ${hashAsString()}`);\n        }\n\n        potentialName = hashAsString();\n      }\n\n      (<any>names[idx]) = item.name ?? (idx === all.length - 1 ? 'main' : potentialName);\n\n      return module;\n    }),\n  );\n\n  if (!names.includes('main')) {\n    throw new Error('manifest with multiple modules must designate one \"main\" module');\n  }\n\n  return [manifestOpts, names, manifestsWasm];\n}\n", "export async function responseToModule(\n  response: Response,\n  hasHash?: boolean,\n): Promise<{ module: WebAssembly.Module; data?: ArrayBuffer }> {\n  if (String(response.headers.get('Content-Type')).split(';')[0] === 'application/octet-stream') {\n    const headers = new Headers(response.headers);\n    headers.set('Content-Type', 'application/wasm');\n\n    response = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: headers,\n    });\n  }\n\n  // XXX(chrisdickinson): Note that we want to pass a `Response` to WebAssembly.compileStreaming if we\n  // can to play nicely with V8's code caching [1]. At the same time, we need the original ArrayBuffer data\n  // to verify any hashes. There's no way back to bytes from `WebAssembly.Module`, so we have to `.clone()`\n  // the response to get the `ArrayBuffer` data if we need to check a hash.\n  //\n  // [1]: https://v8.dev/blog/wasm-code-caching#algorithm\n  const data = hasHash ? await response.clone().arrayBuffer() : undefined;\n  const module = await WebAssembly.compileStreaming(response);\n\n  return { module, data };\n}\n", "import {\n  LogLevel,\n  MemoryOptions,\n  type PluginConfig,\n  PluginOutput,\n  LogLevelPriority,\n  priorityToLogLevel,\n  logLevelToPriority,\n} from './interfaces.ts';\nimport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nexport const BEGIN = Symbol('begin');\nexport const END = Symbol('end');\nexport const ENV = Symbol('env');\nexport const SET_HOST_CONTEXT = Symbol('set-host-context');\nexport const GET_BLOCK = Symbol('get-block');\nexport const IMPORT_STATE = Symbol('import-state');\nexport const EXPORT_STATE = Symbol('export-state');\nexport const STORE = Symbol('store-value');\nexport const RESET = Symbol('reset');\n\nexport class Block {\n  buffer: ArrayBufferLike;\n  view: DataView;\n  local: boolean;\n\n  get byteLength(): number {\n    return this.buffer.byteLength;\n  }\n\n  constructor(arrayBuffer: ArrayBufferLike, local: boolean) {\n    this.buffer = arrayBuffer;\n    this.view = new DataView(this.buffer);\n    this.local = local;\n  }\n\n  static indexToAddress(idx: bigint | number): bigint {\n    return BigInt(idx) << 48n;\n  }\n\n  static addressToIndex(addr: bigint | number): number {\n    return Number(BigInt(addr) >> 48n);\n  }\n\n  static maskAddress(addr: bigint | number): number {\n    return Number(BigInt(addr) & ((1n << 48n) - 1n));\n  }\n}\n\nexport type CallState = {\n  blocks: [ArrayBufferLike | null, number][];\n  stack: [number | null, number | null, number | null][];\n};\n\nexport class CallContext {\n  #stack: [number | null, number | null, number | null][];\n  /** @hidden */\n  #blocks: (Block | null)[] = [];\n  #logger: Console;\n  #logLevel: LogLevelPriority;\n  #decoder: TextDecoder;\n  #encoder: TextEncoder;\n  #arrayBufferType: { new (size: number): ArrayBufferLike };\n  #config: PluginConfig;\n  #vars: Map<string, Uint8Array> = new Map();\n  #varsSize: number;\n  #memoryOptions: MemoryOptions;\n  #hostContext: any;\n\n  /** @hidden */\n  constructor(\n    type: { new (size: number): ArrayBufferLike },\n    logger: Console,\n    logLevel: LogLevelPriority,\n    config: PluginConfig,\n    memoryOptions: MemoryOptions,\n  ) {\n    this.#arrayBufferType = type;\n    this.#logger = logger;\n    this.#logLevel = logLevel ?? 0x7fff_ffff;\n    this.#decoder = new TextDecoder();\n    this.#encoder = new TextEncoder();\n    this.#memoryOptions = memoryOptions;\n\n    this.#varsSize = 0;\n    this.#stack = [];\n\n    // reserve the null page.\n    this.alloc(1);\n\n    this.#config = config;\n  }\n\n  hostContext<T = any>(): T {\n    return this.#hostContext as T;\n  }\n\n  /**\n   * Allocate a chunk of host memory visible to plugins via other extism host functions.\n   * Returns the start address of the block.\n   */\n  alloc(size: bigint | number): bigint {\n    const block = new Block(new this.#arrayBufferType(Number(size)), true);\n    const index = this.#blocks.length;\n    this.#blocks.push(block);\n\n    if (this.#memoryOptions.maxPages) {\n      const pageSize = 64 * 1024;\n      const totalBytes = this.#blocks.reduce((acc, block) => acc + (block?.buffer.byteLength ?? 0), 0);\n      const totalPages = Math.ceil(totalBytes / pageSize);\n\n      if (totalPages > this.#memoryOptions.maxPages) {\n        this.#logger.error(\n          `memory limit exceeded: ${totalPages} pages requested, ${this.#memoryOptions.maxPages} allowed`,\n        );\n        return 0n;\n      }\n    }\n\n    return Block.indexToAddress(index);\n  }\n\n  /**\n   * Read a variable from extism memory by name.\n   *\n   * @returns {@link PluginOutput}\n   */\n  getVariable(name: string): PluginOutput | null {\n    if (!this.#vars.has(name)) {\n      return null;\n    }\n    return new PluginOutput(this.#vars.get(name)!.buffer);\n  }\n\n  /**\n   * Set a variable to a given string or byte array value.\n   */\n  setVariable(name: string, value: string | Uint8Array) {\n    const buffer = typeof value === 'string' ? this.#encoder.encode(value) : value;\n\n    const variable = this.#vars.get(name);\n\n    const newSize = this.#varsSize + buffer.byteLength - (variable?.byteLength || 0);\n    if (newSize > (this.#memoryOptions?.maxVarBytes || Infinity)) {\n      throw new Error(\n        `var memory limit exceeded: ${newSize} bytes requested, ${this.#memoryOptions.maxVarBytes} allowed`,\n      );\n    }\n    this.#varsSize = newSize;\n    this.#vars.set(name, buffer);\n  }\n\n  /**\n   * Delete a variable if present.\n   */\n  deleteVariable(name: string) {\n    const variable = this.#vars.get(name);\n    if (!variable) {\n      return;\n    }\n    this.#vars.delete(name);\n    this.#varsSize -= variable.byteLength;\n  }\n\n  /**\n   * Given an address in extism memory, return a {@link PluginOutput} that represents\n   * a view of that memory. Returns null if the address is invalid.\n   *\n   * @returns bigint\n   */\n  read(addr: bigint | number): PluginOutput | null {\n    const blockIdx = Block.addressToIndex(addr);\n    const block = this.#blocks[blockIdx];\n    if (!block) {\n      return null;\n    }\n\n    const buffer =\n      !(block.buffer instanceof ArrayBuffer) && !CAPABILITIES.allowSharedBufferCodec\n        ? new Uint8Array(block.buffer).slice().buffer\n        : block.buffer;\n\n    return new PluginOutput(buffer);\n  }\n\n  /**\n   * Store a string or Uint8Array value in extism memory.\n   *\n   * @returns bigint\n   */\n  store(input: string | Uint8Array): bigint {\n    const idx = this[STORE](input);\n    if (!idx) {\n      throw new Error('failed to store output');\n    }\n    return Block.indexToAddress(idx);\n  }\n\n  length(addr: bigint): bigint {\n    const blockIdx = Block.addressToIndex(addr);\n    const block = this.#blocks[blockIdx];\n    if (!block) {\n      return 0n;\n    }\n    return BigInt(block.buffer.byteLength);\n  }\n\n  setError(err: string | Error | null = null) {\n    const blockIdx = err ? this[STORE](err instanceof Error ? err.message : err) : 0;\n    if (!blockIdx) {\n      throw new Error('could not store error value');\n    }\n\n    this.#stack[this.#stack.length - 1][2] = blockIdx;\n  }\n\n  get logLevel(): LogLevel {\n    return priorityToLogLevel(this.#logLevel);\n  }\n\n  set logLevel(v: LogLevel) {\n    this.#logLevel = logLevelToPriority(v);\n  }\n\n  /** @hidden */\n  [ENV]: Record<string, CallableFunction> = {\n    alloc: (n: bigint): bigint => {\n      return this.alloc(n);\n    },\n\n    free: (addr: number | bigint): void => {\n      this.#blocks[Block.addressToIndex(addr)] = null;\n    },\n\n    load_u8: (addr: bigint): number => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      return block?.view.getUint8(Number(offset)) as number;\n    },\n\n    load_u64: (addr: bigint): bigint => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      return block?.view.getBigUint64(Number(offset), true) as bigint;\n    },\n\n    store_u8: (addr: bigint, n: number): void => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      block?.view.setUint8(Number(offset), Number(n));\n    },\n\n    store_u64: (addr: bigint, n: bigint): void => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      block?.view.setBigUint64(Number(offset), n, true);\n    },\n\n    input_offset: (): bigint => {\n      const blockIdx = this.#stack[this.#stack.length - 1][0];\n      return Block.indexToAddress(blockIdx || 0);\n    },\n\n    input_length: (): bigint => {\n      return BigInt(this.#input?.byteLength ?? 0);\n    },\n\n    input_load_u8: (addr: bigint): number => {\n      const offset = Block.maskAddress(addr);\n      return this.#input?.view.getUint8(Number(offset)) as number;\n    },\n\n    input_load_u64: (addr: bigint): bigint => {\n      const offset = Block.maskAddress(addr);\n      return this.#input?.view.getBigUint64(Number(offset), true) as bigint;\n    },\n\n    output_set: (addr: bigint, length: bigint): void => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        throw new Error(`cannot assign to this block (addr=${addr.toString(16).padStart(16, '0')}; length=${length})`);\n      }\n\n      if (length > block.buffer.byteLength) {\n        throw new Error('length longer than target block');\n      }\n\n      this.#stack[this.#stack.length - 1][1] = blockIdx;\n    },\n\n    error_set: (addr: bigint): void => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        throw new Error('cannot assign error to this block');\n      }\n\n      this.#stack[this.#stack.length - 1][2] = blockIdx;\n    },\n\n    error_get: (): bigint => {\n      const error = this.#stack[this.#stack.length - 1][2];\n      if (error) {\n        return Block.indexToAddress(error);\n      }\n      return 0n;\n    },\n\n    config_get: (addr: bigint): bigint => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        return 0n;\n      }\n\n      try {\n        const key = item.string();\n        if (key in this.#config) {\n          return this.store(this.#config[key]);\n        }\n      } finally {\n        this[ENV].free(addr);\n      }\n\n      return 0n;\n    },\n\n    var_get: (addr: bigint): bigint => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        return 0n;\n      }\n\n      try {\n        const key = item.string();\n\n        const result = this.getVariable(key);\n        const stored = result ? this[STORE](result.bytes()) || 0 : 0;\n        return Block.indexToAddress(stored);\n      } finally {\n        this[ENV].free(addr);\n      }\n    },\n\n    var_set: (addr: bigint, valueaddr: bigint): void => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        this.#logger.error(`attempted to set variable using invalid key address (addr=\"${addr.toString(16)}H\")`);\n        return;\n      }\n\n      const key = item.string();\n\n      if (valueaddr === 0n) {\n        this.deleteVariable(key);\n        return;\n      }\n\n      const valueBlock = this.#blocks[Block.addressToIndex(valueaddr)];\n      if (!valueBlock) {\n        this.#logger.error(\n          `attempted to set variable to invalid address (key=\"${key}\"; addr=\"${valueaddr.toString(16)}H\")`,\n        );\n        return;\n      }\n\n      try {\n        // Copy the variable value out of the block for TWO reasons:\n        // 1. Variables outlive blocks -- blocks are reset after each invocation.\n        // 2. If the block is backed by a SharedArrayBuffer, we can't read text out of it directly (in many browser contexts.)\n        const copied = new Uint8Array(valueBlock.buffer.byteLength);\n        copied.set(new Uint8Array(valueBlock.buffer), 0);\n        this.setVariable(key, copied);\n      } catch (err: any) {\n        this.#logger.error(err.message);\n        this.setError(err);\n        return;\n      }\n    },\n\n    http_request: (_requestOffset: bigint, _bodyOffset: bigint): bigint => {\n      this.#logger.error('http_request is not enabled');\n      return 0n;\n    },\n\n    http_status_code: (): number => {\n      this.#logger.error('http_status_code is not enabled');\n      return 0;\n    },\n\n    http_headers: (): bigint => {\n      this.#logger.error('http_headers is not enabled');\n      return 0n;\n    },\n\n    length: (addr: bigint): bigint => {\n      return this.length(addr);\n    },\n\n    length_unsafe: (addr: bigint): bigint => {\n      return this.length(addr);\n    },\n\n    log_warn: this.#handleLog.bind(this, logLevelToPriority('warn'), 'warn'),\n    log_info: this.#handleLog.bind(this, logLevelToPriority('info'), 'info'),\n    log_debug: this.#handleLog.bind(this, logLevelToPriority('debug'), 'debug'),\n    log_error: this.#handleLog.bind(this, logLevelToPriority('error'), 'error'),\n    log_trace: this.#handleLog.bind(this, logLevelToPriority('trace'), 'trace'),\n\n    get_log_level: (): number => {\n      return isFinite(this.#logLevel) ? this.#logLevel : 0xffff_ffff;\n    },\n  };\n\n  /** @hidden */\n  #handleLog(incomingLevel: LogLevelPriority, level: LogLevel, addr: bigint) {\n    const blockIdx = Block.addressToIndex(addr);\n    const block = this.#blocks[blockIdx];\n    if (!block) {\n      this.#logger.error(\n        `failed to log(${level}): bad block reference in addr 0x${addr.toString(16).padStart(64, '0')}`,\n      );\n      return;\n    }\n    try {\n      if (this.#logLevel <= incomingLevel) {\n        const text = this.#decoder.decode(block.buffer);\n        (this.#logger[level as keyof Console] as any)(text);\n      }\n    } finally {\n      this.#blocks[blockIdx] = null;\n    }\n  }\n\n  /** @hidden */\n  get #input(): Block | null {\n    const idx = this.#stack[this.#stack.length - 1][0];\n    if (idx === null) {\n      return null;\n    }\n    return this.#blocks[idx];\n  }\n\n  /** @hidden */\n  [RESET]() {\n    this.#hostContext = null;\n\n    // preserve the null page.\n    this.#blocks.length = 1;\n\n    // ... but dump the stack items.\n    this.#stack.length = 0;\n  }\n\n  /** @hidden */\n  [GET_BLOCK](index: number): Block {\n    const block = this.#blocks[index];\n    if (!block) {\n      throw new Error(`invalid block index: ${index}`);\n    }\n    return block;\n  }\n\n  /** @hidden */\n  [IMPORT_STATE](state: CallState, copy: boolean = false) {\n    // eslint-disable-next-line prefer-const\n    for (let [buf, idx] of state.blocks) {\n      if (buf && copy) {\n        const dst = new Uint8Array(new this.#arrayBufferType(Number(buf.byteLength)));\n        dst.set(new Uint8Array(buf));\n        buf = dst.buffer;\n      }\n      this.#blocks[idx] = buf ? new Block(buf, false) : null;\n    }\n    this.#stack = state.stack;\n  }\n\n  /** @hidden */\n  [EXPORT_STATE](): CallState {\n    return {\n      stack: this.#stack.slice(),\n      blocks: this.#blocks\n        .map((block, idx) => {\n          if (!block) {\n            return [null, idx];\n          }\n\n          if (block.local) {\n            block.local = false;\n            return [block.buffer, idx];\n          }\n          return null;\n        })\n        .filter(Boolean) as [ArrayBufferLike, number][],\n    };\n  }\n\n  /** @hidden */\n  [STORE](input?: string | Uint8Array): number | null {\n    if (typeof input === 'string') {\n      input = this.#encoder.encode(input);\n    }\n\n    if (!input) {\n      return null;\n    }\n\n    if (input instanceof Uint8Array) {\n      if (\n        input.buffer.constructor === this.#arrayBufferType &&\n        input.byteOffset === 0 &&\n        input.byteLength === input.buffer.byteLength\n      ) {\n        // no action necessary, wrap it up in a block\n        const idx = this.#blocks.length;\n        this.#blocks.push(new Block(input.buffer, true));\n        return idx;\n      }\n      const idx = Block.addressToIndex(this.alloc(input.length));\n      const block = this.#blocks[idx] as Block;\n      const buf = new Uint8Array(block.buffer);\n      buf.set(input, 0);\n      return idx;\n    }\n\n    return input;\n  }\n\n  /** @hidden */\n  [SET_HOST_CONTEXT](hostContext: any) {\n    this.#hostContext = hostContext;\n  }\n\n  /** @hidden */\n  [BEGIN](input: number | null) {\n    this.#stack.push([input, null, null]);\n  }\n\n  /** @hidden */\n  [END](): [number | null, number | null] {\n    this.#hostContext = null;\n    const [, outputIdx, errorIdx] = this.#stack.pop() as (number | null)[];\n    const outputPosition = errorIdx === null ? 1 : 0;\n    const idx = errorIdx ?? outputIdx;\n    const result: [number | null, number | null] = [null, null];\n\n    if (idx === null) {\n      return result;\n    }\n\n    const block = this.#blocks[idx];\n\n    if (block === null) {\n      // TODO: this might be an error? we got an output idx but it referred to a freed (or non-existant) block\n      return result;\n    }\n\n    result[outputPosition] = idx;\n\n    return result;\n  }\n}\n", "import { WASI } from 'wasi';\nimport { type InternalWasi } from '../interfaces.ts';\nimport { devNull } from 'node:os';\nimport { open } from 'node:fs/promises';\nimport { closeSync } from 'node:fs';\n\nasync function createDevNullFDs() {\n  const [stdin, stdout] = await Promise.all([open(devNull, 'r'), open(devNull, 'w')]);\n  let needsClose = true;\n  // TODO: make this check always run when bun fixes [1], so `fs.promises.open()` returns a `FileHandle` as expected.\n  // [1]: https://github.com/oven-sh/bun/issues/5918\n  let close = async () => {\n    closeSync(stdin as any);\n    closeSync(stdout as any);\n  };\n  if (typeof stdin !== 'number') {\n    const fr = new globalThis.FinalizationRegistry((held: number) => {\n      try {\n        if (needsClose) closeSync(held);\n      } catch {\n        // The fd may already be closed.\n      }\n    });\n\n    fr.register(stdin, stdin.fd);\n    fr.register(stdout, stdout.fd);\n    close = async () => {\n      needsClose = false;\n      await Promise.all([stdin.close(), stdout.close()]).catch(() => {});\n    };\n  }\n\n  return {\n    close,\n    fds: [stdin.fd, stdout.fd, stdout.fd],\n  };\n}\n\nexport async function loadWasi(\n  allowedPaths: { [from: string]: string },\n  enableWasiOutput: boolean,\n): Promise<InternalWasi> {\n  const {\n    close,\n    fds: [stdin, stdout, stderr],\n  } = enableWasiOutput ? { async close() {}, fds: [0, 1, 2] } : await createDevNullFDs();\n\n  const context = new WASI({\n    version: 'preview1',\n    preopens: allowedPaths,\n    stdin,\n    stdout,\n    stderr,\n  } as any);\n\n  return {\n    async importObject() {\n      return context.wasiImport;\n    },\n\n    async close() {\n      await close();\n    },\n\n    async initialize(instance: WebAssembly.Instance) {\n      const memory = instance.exports.memory as WebAssembly.Memory;\n\n      if (!memory) {\n        throw new Error('The module has to export a default memory.');\n      }\n\n      if (instance.exports._initialize) {\n        const init = instance.exports._initialize as CallableFunction;\n        if (context.initialize) {\n          context.initialize({\n            exports: {\n              memory,\n              _initialize: () => {\n                init();\n              },\n            },\n          });\n        } else {\n          init();\n        }\n      } else {\n        context.start({\n          exports: {\n            memory,\n            _start: () => {},\n          },\n        });\n      }\n    },\n  };\n}\n", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import { minimatch } from 'minimatch';\n\nexport function matches(text: string, pattern: string): boolean {\n  return minimatch(text, pattern);\n}\n", "import { CallContext, ENV } from './call-context.ts';\nimport { MemoryOptions } from './interfaces.ts';\nimport { EXTISM_ENV } from './foreground-plugin.ts';\nimport { matches } from './polyfills/deno-minimatch.ts';\n\nexport class HttpContext {\n  fetch: typeof fetch;\n  lastStatusCode: number;\n  lastHeaders: Record<string, string> | null;\n  allowedHosts: string[];\n  memoryOptions: MemoryOptions;\n\n  constructor(\n    _fetch: typeof fetch,\n    allowedHosts: string[],\n    memoryOptions: MemoryOptions,\n    allowResponseHeaders: boolean,\n  ) {\n    this.fetch = _fetch;\n    this.allowedHosts = allowedHosts;\n    this.lastStatusCode = 0;\n    this.memoryOptions = memoryOptions;\n    this.lastHeaders = allowResponseHeaders ? {} : null;\n  }\n\n  contribute(functions: Record<string, Record<string, any>>) {\n    functions[EXTISM_ENV] ??= {};\n    functions[EXTISM_ENV].http_request = (callContext: CallContext, reqaddr: bigint, bodyaddr: bigint) =>\n      this.makeRequest(callContext, reqaddr, bodyaddr);\n    functions[EXTISM_ENV].http_status_code = () => this.lastStatusCode;\n    functions[EXTISM_ENV].http_headers = (callContext: CallContext) => {\n      if (this.lastHeaders === null) {\n        return 0n;\n      }\n      return callContext.store(JSON.stringify(this.lastHeaders));\n    };\n  }\n\n  async makeRequest(callContext: CallContext, reqaddr: bigint, bodyaddr: bigint) {\n    if (this.lastHeaders !== null) {\n      this.lastHeaders = {};\n    }\n    this.lastStatusCode = 0;\n\n    const req = callContext.read(reqaddr);\n    if (req === null) {\n      return 0n;\n    }\n\n    const { headers, header, url: rawUrl, method: m } = req.json();\n    const method = m ?? 'GET';\n    const url = new URL(rawUrl);\n\n    const isAllowed = this.allowedHosts.some((allowedHost) => {\n      return allowedHost === url.hostname || matches(url.hostname, allowedHost);\n    });\n\n    if (!isAllowed) {\n      throw new Error(`Call error: HTTP request to \"${url}\" is not allowed (no allowedHosts match \"${url.hostname}\")`);\n    }\n\n    const body = bodyaddr === 0n || method === 'GET' || method === 'HEAD' ? null : callContext.read(bodyaddr)?.bytes();\n    const fetch = this.fetch;\n    const response = await fetch(rawUrl, {\n      headers: headers || header,\n      method,\n      ...(body ? { body: body.slice() } : {}),\n    });\n\n    this.lastStatusCode = response.status;\n\n    if (this.lastHeaders !== null) {\n      this.lastHeaders = Object.fromEntries(response.headers);\n    }\n\n    try {\n      const bytes = this.memoryOptions.maxHttpResponseBytes\n        ? await readBodyUpTo(response, this.memoryOptions.maxHttpResponseBytes)\n        : new Uint8Array(await response.arrayBuffer());\n\n      const result = callContext.store(bytes);\n\n      return result;\n    } catch (err) {\n      if (err instanceof Error) {\n        const ptr = callContext.store(new TextEncoder().encode(err.message));\n        callContext[ENV].log_error(ptr);\n        return 0n;\n      }\n      return 0n;\n    }\n  }\n}\n\nasync function readBodyUpTo(response: Response, maxBytes: number): Promise<Uint8Array> {\n  const reader = response.body?.getReader();\n  if (!reader) {\n    return new Uint8Array(0);\n  }\n\n  let receivedLength = 0;\n  const chunks = [];\n\n  while (receivedLength < maxBytes) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    receivedLength += value.length;\n    if (receivedLength >= maxBytes) {\n      throw new Error(`Response body exceeded ${maxBytes} bytes`);\n    }\n  }\n\n  const limitedResponseBody = new Uint8Array(receivedLength);\n  let position = 0;\n  for (const chunk of chunks) {\n    limitedResponseBody.set(chunk, position);\n    position += chunk.length;\n  }\n\n  return limitedResponseBody;\n}\n", "import { BEGIN, CallContext, END, ENV, GET_BLOCK, RESET, SET_HOST_CONTEXT, STORE } from './call-context.ts';\nimport { type InternalConfig, InternalWasi, PluginOutput } from './interfaces.ts';\nimport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\nimport { loadWasi } from './polyfills/deno-wasi.ts';\nimport { HttpContext } from './http-context.ts';\n\nexport const EXTISM_ENV = 'extism:host/env';\n\ntype InstantiatedModule = [WebAssembly.Module, WebAssembly.Instance];\n\ninterface SuspendingCtor {\n  new (fn: CallableFunction): any;\n}\n\nconst AsyncFunction = (async () => {}).constructor;\nconst Suspending: SuspendingCtor | undefined = (WebAssembly as any).Suspending;\nconst promising: CallableFunction | undefined = (WebAssembly as any).promising;\n\nexport class ForegroundPlugin {\n  #context: CallContext;\n  #instancePair: InstantiatedModule;\n  #active: boolean = false;\n  #wasi: InternalWasi[];\n  #opts: InternalConfig;\n  #suspendsOnInvoke: boolean;\n\n  constructor(\n    opts: InternalConfig,\n    context: CallContext,\n    instancePair: InstantiatedModule,\n    wasi: InternalWasi[],\n    suspendsOnInvoke: boolean,\n  ) {\n    this.#context = context;\n    this.#instancePair = instancePair;\n    this.#wasi = wasi;\n    this.#opts = opts;\n    this.#suspendsOnInvoke = suspendsOnInvoke;\n  }\n\n  async reset(): Promise<boolean> {\n    if (this.isActive()) {\n      return false;\n    }\n\n    this.#context[RESET]();\n    return true;\n  }\n\n  isActive() {\n    return this.#active;\n  }\n\n  async functionExists(funcName: string): Promise<boolean> {\n    return typeof this.#instancePair[1].exports[funcName] === 'function';\n  }\n\n  async callBlock(funcName: string, input: number | null): Promise<[number | null, number | null]> {\n    this.#active = true;\n    const func: CallableFunction | undefined = this.#instancePair[1].exports[funcName] as CallableFunction;\n\n    if (!func) {\n      throw Error(`Plugin error: function \"${funcName}\" does not exist`);\n    }\n\n    if (typeof func !== 'function') {\n      throw Error(`Plugin error: export \"${funcName}\" is not a function`);\n    }\n\n    this.#context[BEGIN](input ?? null);\n    try {\n      this.#suspendsOnInvoke ? await (promising as any)(func)() : func();\n      return this.#context[END]();\n    } catch (err) {\n      this.#context[END]();\n      throw err;\n    } finally {\n      this.#active = false;\n    }\n  }\n\n  async call<T = any>(funcName: string, input?: string | Uint8Array, hostContext?: T): Promise<PluginOutput | null> {\n    this.#context[RESET]();\n\n    const inputIdx = this.#context[STORE](input);\n    this.#context[SET_HOST_CONTEXT](hostContext);\n\n    const [errorIdx, outputIdx] = await this.callBlock(funcName, inputIdx);\n    const shouldThrow = errorIdx !== null;\n    const idx = errorIdx ?? outputIdx;\n\n    if (idx === null) {\n      return null;\n    }\n\n    const block = this.#context[GET_BLOCK](idx);\n    if (!block) {\n      return null;\n    }\n\n    const output = new PluginOutput(block.buffer);\n    if (shouldThrow) {\n      throw new Error(`Plugin-originated error: ${output.string()}`);\n    }\n    return output;\n  }\n\n  async getExports(): Promise<WebAssembly.ModuleExportDescriptor[]> {\n    return WebAssembly.Module.exports(this.#instancePair[0]) || [];\n  }\n\n  async getImports(): Promise<WebAssembly.ModuleImportDescriptor[]> {\n    return WebAssembly.Module.imports(this.#instancePair[0]) || [];\n  }\n\n  async getInstance(): Promise<WebAssembly.Instance> {\n    return this.#instancePair[1];\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(this.#wasi.map((xs) => xs.close()));\n    this.#wasi.length = 0;\n  }\n}\n\nexport async function createForegroundPlugin(\n  opts: InternalConfig,\n  names: string[],\n  modules: WebAssembly.Module[],\n  context: CallContext = new CallContext(ArrayBuffer, opts.logger, opts.logLevel, opts.config, opts.memory),\n): Promise<ForegroundPlugin> {\n  const imports: Record<string, Record<string, any>> = {\n    [EXTISM_ENV]: context[ENV],\n    env: {},\n  };\n\n  let suspendsOnInvoke = false;\n  for (const namespace in opts.functions) {\n    imports[namespace] = imports[namespace] || {};\n    for (const [name, func] of Object.entries(opts.functions[namespace])) {\n      const isAsync = func.constructor === AsyncFunction;\n      suspendsOnInvoke ||= isAsync;\n      const wrapped = func.bind(null, context);\n      imports[namespace][name] = isAsync ? new Suspending!(wrapped) : wrapped;\n    }\n  }\n\n  if (suspendsOnInvoke && (!Suspending || !promising)) {\n    throw new TypeError(\n      'This platform does not support async function imports on the main thread; consider using `runInWorker`.',\n    );\n  }\n\n  // find the \"main\" module and try to instantiate it.\n  const mainIndex = names.indexOf('main');\n  if (mainIndex === -1) {\n    throw new Error('Unreachable: manifests must have at least one \"main\" module. Enforced by \"src/manifest.ts\")');\n  }\n  const seen: Map<WebAssembly.Module, WebAssembly.Instance> = new Map();\n  const wasiList: InternalWasi[] = [];\n\n  const mutableFlags = { suspendsOnInvoke };\n  const instance = await instantiateModule(\n    context,\n    ['main'],\n    modules[mainIndex],\n    imports,\n    opts,\n    wasiList,\n    names,\n    modules,\n    seen,\n    mutableFlags,\n  );\n\n  return new ForegroundPlugin(opts, context, [modules[mainIndex], instance], wasiList, mutableFlags.suspendsOnInvoke);\n}\n\nasync function instantiateModule(\n  context: CallContext,\n  current: string[],\n  module: WebAssembly.Module,\n  imports: Record<string, Record<string, any>>,\n  opts: InternalConfig,\n  wasiList: InternalWasi[],\n  names: string[],\n  modules: WebAssembly.Module[],\n  linked: Map<WebAssembly.Module, WebAssembly.Instance | null>,\n  mutableFlags: { suspendsOnInvoke: boolean },\n) {\n  linked.set(module, null);\n\n  const instantiationImports: Record<string, Record<string, WebAssembly.ExportValue | CallableFunction>> = {};\n  const requested = WebAssembly.Module.imports(module);\n\n  let wasi = null;\n  for (const { kind, module, name } of requested) {\n    const nameIdx = names.indexOf(module);\n\n    if (nameIdx === -1) {\n      if (module === 'wasi_snapshot_preview1' && wasi === null) {\n        if (!CAPABILITIES.supportsWasiPreview1) {\n          throw new Error('WASI is not supported on this platform');\n        }\n\n        if (!opts.wasiEnabled) {\n          throw new Error('WASI is not enabled; see the \"useWasi\" plugin option');\n        }\n\n        if (wasi === null) {\n          wasi = await loadWasi(opts.allowedPaths, opts.enableWasiOutput);\n          wasiList.push(wasi);\n          imports.wasi_snapshot_preview1 = await wasi.importObject();\n        }\n      }\n\n      // lookup from \"imports\"\n      if (!Object.hasOwnProperty.call(imports, module)) {\n        throw new Error(\n          `from module \"${current.join(\n            '\"/\"',\n          )}\": cannot resolve import \"${module}\" \"${name}\": not provided by host imports nor linked manifest items`,\n        );\n      }\n\n      if (!Object.hasOwnProperty.call(imports[module], name)) {\n        throw new Error(\n          `from module \"${current.join(\n            '\"/\"',\n          )}\": cannot resolve import \"${module}\" \"${name}\" (\"${module}\" is a host module, but does not contain \"${name}\")`,\n        );\n      }\n\n      // XXX(chrisdickinson): This is a bit of a hack, admittedly. So what's going on here?\n      //\n      // JSPI is going on here. Let me explain: at the time of writing, the js-sdk supports\n      // JSPI by detecting AsyncFunction use in the `functions` parameter. When we detect an\n      // async function in imports we _must_ mark all exported Wasm functions as \"promising\" --\n      // that is, they might call a host function that suspends the stack.\n      //\n      // If we were to mark extism's http_request as async, we would _always_ set exports as\n      // \"promising\". This adds unnecessary overhead for folks who aren't using `http_request`.\n      // Instead, we detect if any of the manifest items *import* `http_request`. If they\n      // haven't overridden the default CallContext implementation, we provide an HttpContext\n      // on-demand.\n      //\n      // Unfortuantely this duplicates a little bit of logic-- in particular, we have to bind\n      // CallContext to each of the HttpContext contributions (See \"REBIND\" below.)\n      if (\n        module === EXTISM_ENV &&\n        name === 'http_request' &&\n        promising &&\n        imports[module][name] === context[ENV].http_request\n      ) {\n        const httpContext = new HttpContext(opts.fetch, opts.allowedHosts, opts.memory, opts.allowHttpResponseHeaders);\n\n        mutableFlags.suspendsOnInvoke = true;\n\n        const contributions = {} as any;\n        httpContext.contribute(contributions);\n        for (const [key, entry] of Object.entries(contributions[EXTISM_ENV] as { [k: string]: CallableFunction })) {\n          // REBIND:\n          imports[module][key] = (entry as any).bind(null, context);\n        }\n        imports[module][name] = new Suspending!(imports[module][name]);\n      }\n\n      switch (kind) {\n        case `function`: {\n          instantiationImports[module] ??= {};\n          instantiationImports[module][name] = imports[module][name] as CallableFunction;\n          break;\n        }\n        default:\n          throw new Error(\n            `from module \"${current.join(\n              '\"/\"',\n            )}\": in import \"${module}\" \"${name}\", \"${kind}\"-typed host imports are not supported yet`,\n          );\n      }\n    } else {\n      // lookup from \"linked\"\n      const provider = modules[nameIdx];\n      const providerExports = WebAssembly.Module.exports(provider);\n\n      const target = providerExports.find((xs) => {\n        return xs.name === name && xs.kind === kind;\n      });\n\n      if (!target) {\n        throw new Error(\n          `from module \"${current.join('\"/\"')}\": cannot import \"${module}\" \"${name}\"; no export matched request`,\n        );\n      }\n\n      // If the dependency provides \"_start\", treat it as a WASI Command module; instantiate it (and its subtree) directly.\n      const instance = providerExports.find((xs) => xs.name === '_start')\n        ? await instantiateModule(\n            context,\n            [...current, module],\n            provider,\n            imports,\n            opts,\n            wasiList,\n            names,\n            modules,\n            new Map(),\n            mutableFlags,\n          )\n        : !linked.has(provider)\n        ? (await instantiateModule(\n            context,\n            [...current, module],\n            provider,\n            imports,\n            opts,\n            wasiList,\n            names,\n            modules,\n            linked,\n            mutableFlags,\n          ),\n          linked.get(provider))\n        : linked.get(provider);\n\n      if (!instance) {\n        // circular import, either make a trampoline or bail\n        if (kind === 'function') {\n          instantiationImports[module] = {};\n          let cached: CallableFunction | null = null;\n          instantiationImports[module][name] = (...args: (number | bigint)[]) => {\n            if (cached) {\n              return cached(...args);\n            }\n            const instance = linked.get(modules[nameIdx]);\n            if (!instance) {\n              throw new Error(\n                `from module instance \"${current.join('\"/\"')}\": target module \"${module}\" was never instantiated`,\n              );\n            }\n            cached = instance.exports[name] as CallableFunction;\n            return cached(...args);\n          };\n        } else {\n          throw new Error(\n            `from module \"${current.join(\n              '\"/\"',\n            )}\": cannot import \"${module}\" \"${name}\"; circular imports of type=\"${kind}\" are not supported`,\n          );\n        }\n      } else {\n        // Add each requested import value piecemeal, since we have to validate that _all_ import requests are satisfied by this\n        // module.\n        instantiationImports[module] ??= {};\n        instantiationImports[module][name] = instance.exports[name] as WebAssembly.ExportValue;\n      }\n    }\n  }\n\n  const instance = await WebAssembly.instantiate(module, instantiationImports);\n\n  const guestType = instance.exports.hs_init\n    ? 'haskell'\n    : instance.exports._initialize\n    ? 'reactor'\n    : instance.exports._start\n    ? 'command'\n    : 'none';\n\n  if (wasi) {\n    await wasi?.initialize(instance);\n    if (instance.exports.hs_init) {\n      (instance.exports.hs_init as CallableFunction)();\n    }\n  } else {\n    switch (guestType) {\n      case 'command':\n        if (instance.exports._initialize) {\n          (instance.exports._initialize as CallableFunction)();\n        }\n\n        (instance.exports._start as CallableFunction)();\n        break;\n      case 'reactor':\n        (instance.exports._initialize as CallableFunction)();\n        break;\n      case 'haskell':\n        (instance.exports.hs_init as CallableFunction)();\n        break;\n    }\n  }\n\n  linked.set(module, instance);\n  return instance;\n}\n", "export const WORKER_URL = new URL(\"data:text/javascript;base64,dmFyIHZlPU9iamVjdC5jcmVhdGU7dmFyIHZ0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgRWU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgQWU9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIGtlPU9iamVjdC5nZXRQcm90b3R5cGVPZixTZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBUZT0ocix0LGUpPT50IGluIHI/dnQocix0LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSk6clt0XT1lO3ZhciBCdD0ocix0KT0+KCk9Pih0fHxyKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpO3ZhciBDZT0ocix0LGUscyk9PntpZih0JiZ0eXBlb2YgdD09Im9iamVjdCJ8fHR5cGVvZiB0PT0iZnVuY3Rpb24iKWZvcihsZXQgbiBvZiBBZSh0KSkhU2UuY2FsbChyLG4pJiZuIT09ZSYmdnQocixuLHtnZXQ6KCk9PnRbbl0sZW51bWVyYWJsZTohKHM9RWUodCxuKSl8fHMuZW51bWVyYWJsZX0pO3JldHVybiByfTt2YXIgT2U9KHIsdCxlKT0+KGU9ciE9bnVsbD92ZShrZShyKSk6e30sQ2UodHx8IXJ8fCFyLl9fZXNNb2R1bGU/dnQoZSwiZGVmYXVsdCIse3ZhbHVlOnIsZW51bWVyYWJsZTohMH0pOmUscikpO3ZhciBVdD0ocix0LGUpPT4oVGUocix0eXBlb2YgdCE9InN5bWJvbCI/dCsiIjp0LGUpLGUpLEV0PShyLHQsZSk9PntpZighdC5oYXMocikpdGhyb3cgVHlwZUVycm9yKCJDYW5ub3QgIitlKX07dmFyIGg9KHIsdCxlKT0+KEV0KHIsdCwicmVhZCBmcm9tIHByaXZhdGUgZmllbGQiKSxlP2UuY2FsbChyKTp0LmdldChyKSksRT0ocix0LGUpPT57aWYodC5oYXMocikpdGhyb3cgVHlwZUVycm9yKCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlIik7dCBpbnN0YW5jZW9mIFdlYWtTZXQ/dC5hZGQocik6dC5zZXQocixlKX0seD0ocix0LGUscyk9PihFdChyLHQsIndyaXRlIHRvIHByaXZhdGUgZmllbGQiKSxzP3MuY2FsbChyLGUpOnQuc2V0KHIsZSksZSk7dmFyIEQ9KHIsdCxlKT0+KEV0KHIsdCwiYWNjZXNzIHByaXZhdGUgbWV0aG9kIiksZSk7dmFyIEp0PUJ0KChEcyxYdCk9PnsidXNlIHN0cmljdCI7WHQuZXhwb3J0cz1HdDtmdW5jdGlvbiBHdChyLHQsZSl7ciBpbnN0YW5jZW9mIFJlZ0V4cCYmKHI9VnQocixlKSksdCBpbnN0YW5jZW9mIFJlZ0V4cCYmKHQ9VnQodCxlKSk7dmFyIHM9cXQocix0LGUpO3JldHVybiBzJiZ7c3RhcnQ6c1swXSxlbmQ6c1sxXSxwcmU6ZS5zbGljZSgwLHNbMF0pLGJvZHk6ZS5zbGljZShzWzBdK3IubGVuZ3RoLHNbMV0pLHBvc3Q6ZS5zbGljZShzWzFdK3QubGVuZ3RoKX19ZnVuY3Rpb24gVnQocix0KXt2YXIgZT10Lm1hdGNoKHIpO3JldHVybiBlP2VbMF06bnVsbH1HdC5yYW5nZT1xdDtmdW5jdGlvbiBxdChyLHQsZSl7dmFyIHMsbixpLG8sYSxsPWUuaW5kZXhPZihyKSx1PWUuaW5kZXhPZih0LGwrMSksYz1sO2lmKGw+PTAmJnU+MCl7aWYocj09PXQpcmV0dXJuW2wsdV07Zm9yKHM9W10saT1lLmxlbmd0aDtjPj0wJiYhYTspYz09bD8ocy5wdXNoKGMpLGw9ZS5pbmRleE9mKHIsYysxKSk6cy5sZW5ndGg9PTE/YT1bcy5wb3AoKSx1XToobj1zLnBvcCgpLG48aSYmKGk9bixvPXUpLHU9ZS5pbmRleE9mKHQsYysxKSksYz1sPHUmJmw+PTA/bDp1O3MubGVuZ3RoJiYoYT1baSxvXSl9cmV0dXJuIGF9fSk7dmFyIG5lPUJ0KChqcyxzZSk9Pnt2YXIgS3Q9SnQoKTtzZS5leHBvcnRzPVdlO3ZhciBadD0iXDBTTEFTSCIrTWF0aC5yYW5kb20oKSsiXDAiLFl0PSJcME9QRU4iK01hdGgucmFuZG9tKCkrIlwwIixJdD0iXDBDTE9TRSIrTWF0aC5yYW5kb20oKSsiXDAiLFF0PSJcMENPTU1BIitNYXRoLnJhbmRvbSgpKyJcMCIsdGU9IlwwUEVSSU9EIitNYXRoLnJhbmRvbSgpKyJcMCI7ZnVuY3Rpb24gT3Qocil7cmV0dXJuIHBhcnNlSW50KHIsMTApPT1yP3BhcnNlSW50KHIsMTApOnIuY2hhckNvZGVBdCgwKX1mdW5jdGlvbiBMZShyKXtyZXR1cm4gci5zcGxpdCgiXFxcXCIpLmpvaW4oWnQpLnNwbGl0KCJcXHsiKS5qb2luKFl0KS5zcGxpdCgiXFx9Iikuam9pbihJdCkuc3BsaXQoIlxcLCIpLmpvaW4oUXQpLnNwbGl0KCJcXC4iKS5qb2luKHRlKX1mdW5jdGlvbiBQZShyKXtyZXR1cm4gci5zcGxpdChadCkuam9pbigiXFwiKS5zcGxpdChZdCkuam9pbigieyIpLnNwbGl0KEl0KS5qb2luKCJ9Iikuc3BsaXQoUXQpLmpvaW4oIiwiKS5zcGxpdCh0ZSkuam9pbigiLiIpfWZ1bmN0aW9uIGVlKHIpe2lmKCFyKXJldHVyblsiIl07dmFyIHQ9W10sZT1LdCgieyIsIn0iLHIpO2lmKCFlKXJldHVybiByLnNwbGl0KCIsIik7dmFyIHM9ZS5wcmUsbj1lLmJvZHksaT1lLnBvc3Qsbz1zLnNwbGl0KCIsIik7b1tvLmxlbmd0aC0xXSs9InsiK24rIn0iO3ZhciBhPWVlKGkpO3JldHVybiBpLmxlbmd0aCYmKG9bby5sZW5ndGgtMV0rPWEuc2hpZnQoKSxvLnB1c2guYXBwbHkobyxhKSksdC5wdXNoLmFwcGx5KHQsbyksdH1mdW5jdGlvbiBXZShyKXtyZXR1cm4gcj8oci5zdWJzdHIoMCwyKT09PSJ7fSImJihyPSJcXHtcXH0iK3Iuc3Vic3RyKDIpKSxydChMZShyKSwhMCkubWFwKFBlKSk6W119ZnVuY3Rpb24gJGUocil7cmV0dXJuInsiK3IrIn0ifWZ1bmN0aW9uIFJlKHIpe3JldHVybi9eLT8wXGQvLnRlc3Qocil9ZnVuY3Rpb24gTmUocix0KXtyZXR1cm4gcjw9dH1mdW5jdGlvbiBCZShyLHQpe3JldHVybiByPj10fWZ1bmN0aW9uIHJ0KHIsdCl7dmFyIGU9W10scz1LdCgieyIsIn0iLHIpO2lmKCFzKXJldHVybltyXTt2YXIgbj1zLnByZSxpPXMucG9zdC5sZW5ndGg/cnQocy5wb3N0LCExKTpbIiJdO2lmKC9cJCQvLnRlc3Qocy5wcmUpKWZvcih2YXIgbz0wO288aS5sZW5ndGg7bysrKXt2YXIgYT1uKyJ7IitzLmJvZHkrIn0iK2lbb107ZS5wdXNoKGEpfWVsc2V7dmFyIGw9L14tP1xkK1wuXC4tP1xkKyg/OlwuXC4tP1xkKyk/JC8udGVzdChzLmJvZHkpLHU9L15bYS16QS1aXVwuXC5bYS16QS1aXSg/OlwuXC4tP1xkKyk/JC8udGVzdChzLmJvZHkpLGM9bHx8dSxtPXMuYm9keS5pbmRleE9mKCIsIik+PTA7aWYoIWMmJiFtKXJldHVybiBzLnBvc3QubWF0Y2goLywuKlx9Lyk/KHI9cy5wcmUrInsiK3MuYm9keStJdCtzLnBvc3QscnQocikpOltyXTt2YXIgcDtpZihjKXA9cy5ib2R5LnNwbGl0KC9cLlwuLyk7ZWxzZSBpZihwPWVlKHMuYm9keSkscC5sZW5ndGg9PT0xJiYocD1ydChwWzBdLCExKS5tYXAoJGUpLHAubGVuZ3RoPT09MSkpcmV0dXJuIGkubWFwKGZ1bmN0aW9uKHhlKXtyZXR1cm4gcy5wcmUrcFswXSt4ZX0pO3ZhciBkO2lmKGMpe3ZhciB5PU90KHBbMF0pLGY9T3QocFsxXSksZz1NYXRoLm1heChwWzBdLmxlbmd0aCxwWzFdLmxlbmd0aCksYj1wLmxlbmd0aD09Mz9NYXRoLmFicyhPdChwWzJdKSk6MSxJPU5lLFM9Zjx5O1MmJihiKj0tMSxJPUJlKTt2YXIgTT1wLnNvbWUoUmUpO2Q9W107Zm9yKHZhciAkPXk7SSgkLGYpOyQrPWIpe3ZhciBDO2lmKHUpQz1TdHJpbmcuZnJvbUNoYXJDb2RlKCQpLEM9PT0iXFwiJiYoQz0iIik7ZWxzZSBpZihDPVN0cmluZygkKSxNKXt2YXIgTD1nLUMubGVuZ3RoO2lmKEw+MCl7dmFyIHN0PW5ldyBBcnJheShMKzEpLmpvaW4oIjAiKTskPDA/Qz0iLSIrc3QrQy5zbGljZSgxKTpDPXN0K0N9fWQucHVzaChDKX19ZWxzZXtkPVtdO2Zvcih2YXIgUj0wO1I8cC5sZW5ndGg7UisrKWQucHVzaC5hcHBseShkLHJ0KHBbUl0sITEpKX1mb3IodmFyIFI9MDtSPGQubGVuZ3RoO1IrKylmb3IodmFyIG89MDtvPGkubGVuZ3RoO28rKyl7dmFyIGE9bitkW1JdK2lbb107KCF0fHxjfHxhKSYmZS5wdXNoKGEpfX1yZXR1cm4gZX19KTtpbXBvcnR7cGFyZW50UG9ydCBhcyBBc31mcm9tIm5vZGU6d29ya2VyX3RocmVhZHMiO3ZhciB1dCxudCxBdD1jbGFzcyBleHRlbmRzIERhdGFWaWV3e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO0UodGhpcyxudCxudWxsKX1qc29uKCl7cmV0dXJuIEpTT04ucGFyc2UodGhpcy5zdHJpbmcoKSl9YXJyYXlCdWZmZXIoKXtyZXR1cm4gdGhpcy5idWZmZXJ9dGV4dCgpe3JldHVybiB0aGlzLnN0cmluZygpfXN0cmluZygpe3JldHVybiBoKEF0LHV0KS5kZWNvZGUodGhpcy5idWZmZXIpfWJ5dGVzKCl7cmV0dXJuIGgodGhpcyxudCk/P3godGhpcyxudCxuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLGgodGhpcyxudCl9c2V0SW50OChlLHMpe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0SW50MTYoZSxzLG4pe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0SW50MzIoZSxzLG4pe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0VWludDgoZSxzKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldFVpbnQxNihlLHMsbil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX1zZXRVaW50MzIoZSxzLG4pe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0RmxvYXQzMihlLHMsbil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX1zZXRGbG9hdDY0KGUscyxuKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldEJpZ0ludDY0KGUscyxuKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldEJpZ1VpbnQ2NChlLHMsbil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX19LGo9QXQ7dXQ9bmV3IFdlYWtNYXAsbnQ9bmV3IFdlYWtNYXAsRShqLHV0LG5ldyBUZXh0RGVjb2Rlcik7dmFyIE49NDtmdW5jdGlvbiBYKHIpe3N3aXRjaChyKXtjYXNlInRyYWNlIjpyZXR1cm4gMDtjYXNlImRlYnVnIjpyZXR1cm4gMTtjYXNlImluZm8iOnJldHVybiAyO2Nhc2Uid2FybiI6cmV0dXJuIDM7Y2FzZSJlcnJvciI6cmV0dXJuIDQ7Y2FzZSJzaWxlbnQiOnJldHVybiAyMTQ3NDgzNjQ3O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgdW5yZWNvZ25pemVkIGxvZyBsZXZlbCAiJHtyfSI7IGV4cGVjdGVkIG9uZSBvZiAidHJhY2UiLCAiZGVidWciLCAiaW5mbyIsICJ3YXJuIiwgImVycm9yIiwgInNpbGVudCJgKX19ZnVuY3Rpb24gRHQocil7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4idHJhY2UiO2Nhc2UgMTpyZXR1cm4iZGVidWciO2Nhc2UgMjpyZXR1cm4iaW5mbyI7Y2FzZSAzOnJldHVybiJ3YXJuIjtjYXNlIDQ6cmV0dXJuImVycm9yIjtjYXNlIDIxNDc0ODM2NDc6cmV0dXJuInNpbGVudCI7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnJlY29nbml6ZWQgbG9nIGxldmVsICIke3J9IjsgZXhwZWN0ZWQgb25lIG9mICJ0cmFjZSIsICJkZWJ1ZyIsICJpbmZvIiwgIndhcm4iLCAiZXJyb3IiLCAic2lsZW50ImApfX12YXIganQ9Z2xvYmFsVGhpcy5XZWJBc3NlbWJseXx8e30saHQ9e3N1cHBvcnRzSlNQcm9taXNlSW50ZXJmYWNlOnR5cGVvZiBqdC5TdXNwZW5kaW5nPT0iZnVuY3Rpb24iJiZ0eXBlb2YganQucHJvbWlzaW5nPT0iZnVuY3Rpb24iLGFsbG93U2hhcmVkQnVmZmVyQ29kZWM6ITEsbWFuaWZlc3RTdXBwb3J0c1BhdGhzOiEwLGNyb3NzT3JpZ2luQ2hlY2tzRW5mb3JjZWQ6ITEsZnNBY2Nlc3M6ITAsaGFzV29ya2VyQ2FwYWJpbGl0eTohMCxzdXBwb3J0c1dhc2lQcmV2aWV3MTohMCxzdXBwb3J0c1RpbWVvdXRzOiEwLGV4dGlzbVN0ZG91dEVudlZhclNldDpCb29sZWFuKHByb2Nlc3MuZW52LkVYVElTTV9FTkFCTEVfV0FTSV9PVVRQVVQpfTt2YXIga3Q9U3ltYm9sKCJiZWdpbiIpLGN0PVN5bWJvbCgiZW5kIiksej1TeW1ib2woImVudiIpLFN0PVN5bWJvbCgic2V0LWhvc3QtY29udGV4dCIpLFR0PVN5bWJvbCgiZ2V0LWJsb2NrIiksZnQ9U3ltYm9sKCJpbXBvcnQtc3RhdGUiKSxwdD1TeW1ib2woImV4cG9ydC1zdGF0ZSIpLFo9U3ltYm9sKCJzdG9yZS12YWx1ZSIpLGR0PVN5bWJvbCgicmVzZXQiKSx3PWNsYXNze2dldCBieXRlTGVuZ3RoKCl7cmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGh9Y29uc3RydWN0b3IodCxlKXt0aGlzLmJ1ZmZlcj10LHRoaXMudmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpLHRoaXMubG9jYWw9ZX1zdGF0aWMgaW5kZXhUb0FkZHJlc3ModCl7cmV0dXJuIEJpZ0ludCh0KTw8NDhufXN0YXRpYyBhZGRyZXNzVG9JbmRleCh0KXtyZXR1cm4gTnVtYmVyKEJpZ0ludCh0KT4+NDhuKX1zdGF0aWMgbWFza0FkZHJlc3ModCl7cmV0dXJuIE51bWJlcihCaWdJbnQodCkmKDFuPDw0OG4pLTFuKX19LEllLFk9Y2xhc3N7Y29uc3RydWN0b3IodCxlLHMsbixpKXt0aGlzLiN0PVtdO3RoaXMuI2k9bmV3IE1hcDt0aGlzW0llXT17YWxsb2M6dD0+dGhpcy5hbGxvYyh0KSxmcmVlOnQ9Pnt0aGlzLiN0W3cuYWRkcmVzc1RvSW5kZXgodCldPW51bGx9LGxvYWRfdTg6dD0+e2xldCBlPXcuYWRkcmVzc1RvSW5kZXgodCkscz13Lm1hc2tBZGRyZXNzKHQpO3JldHVybiB0aGlzLiN0W2VdPy52aWV3LmdldFVpbnQ4KE51bWJlcihzKSl9LGxvYWRfdTY0OnQ9PntsZXQgZT13LmFkZHJlc3NUb0luZGV4KHQpLHM9dy5tYXNrQWRkcmVzcyh0KTtyZXR1cm4gdGhpcy4jdFtlXT8udmlldy5nZXRCaWdVaW50NjQoTnVtYmVyKHMpLCEwKX0sc3RvcmVfdTg6KHQsZSk9PntsZXQgcz13LmFkZHJlc3NUb0luZGV4KHQpLG49dy5tYXNrQWRkcmVzcyh0KTt0aGlzLiN0W3NdPy52aWV3LnNldFVpbnQ4KE51bWJlcihuKSxOdW1iZXIoZSkpfSxzdG9yZV91NjQ6KHQsZSk9PntsZXQgcz13LmFkZHJlc3NUb0luZGV4KHQpLG49dy5tYXNrQWRkcmVzcyh0KTt0aGlzLiN0W3NdPy52aWV3LnNldEJpZ1VpbnQ2NChOdW1iZXIobiksZSwhMCl9LGlucHV0X29mZnNldDooKT0+e2xldCB0PXRoaXMuI2VbdGhpcy4jZS5sZW5ndGgtMV1bMF07cmV0dXJuIHcuaW5kZXhUb0FkZHJlc3ModHx8MCl9LGlucHV0X2xlbmd0aDooKT0+QmlnSW50KHRoaXMuI3A/LmJ5dGVMZW5ndGg/PzApLGlucHV0X2xvYWRfdTg6dD0+e2xldCBlPXcubWFza0FkZHJlc3ModCk7cmV0dXJuIHRoaXMuI3A/LnZpZXcuZ2V0VWludDgoTnVtYmVyKGUpKX0saW5wdXRfbG9hZF91NjQ6dD0+e2xldCBlPXcubWFza0FkZHJlc3ModCk7cmV0dXJuIHRoaXMuI3A/LnZpZXcuZ2V0QmlnVWludDY0KE51bWJlcihlKSwhMCl9LG91dHB1dF9zZXQ6KHQsZSk9PntsZXQgcz13LmFkZHJlc3NUb0luZGV4KHQpLG49dGhpcy4jdFtzXTtpZighbil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBhc3NpZ24gdG8gdGhpcyBibG9jayAoYWRkcj0ke3QudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCIwIil9OyBsZW5ndGg9JHtlfSlgKTtpZihlPm4uYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJsZW5ndGggbG9uZ2VyIHRoYW4gdGFyZ2V0IGJsb2NrIik7dGhpcy4jZVt0aGlzLiNlLmxlbmd0aC0xXVsxXT1zfSxlcnJvcl9zZXQ6dD0+e2xldCBlPXcuYWRkcmVzc1RvSW5kZXgodCk7aWYoIXRoaXMuI3RbZV0pdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYXNzaWduIGVycm9yIHRvIHRoaXMgYmxvY2siKTt0aGlzLiNlW3RoaXMuI2UubGVuZ3RoLTFdWzJdPWV9LGVycm9yX2dldDooKT0+e2xldCB0PXRoaXMuI2VbdGhpcy4jZS5sZW5ndGgtMV1bMl07cmV0dXJuIHQ/dy5pbmRleFRvQWRkcmVzcyh0KTowbn0sY29uZmlnX2dldDp0PT57bGV0IGU9dGhpcy5yZWFkKHQpO2lmKGU9PT1udWxsKXJldHVybiAwbjt0cnl7bGV0IHM9ZS5zdHJpbmcoKTtpZihzIGluIHRoaXMuI2YpcmV0dXJuIHRoaXMuc3RvcmUodGhpcy4jZltzXSl9ZmluYWxseXt0aGlzW3pdLmZyZWUodCl9cmV0dXJuIDBufSx2YXJfZ2V0OnQ9PntsZXQgZT10aGlzLnJlYWQodCk7aWYoZT09PW51bGwpcmV0dXJuIDBuO3RyeXtsZXQgcz1lLnN0cmluZygpLG49dGhpcy5nZXRWYXJpYWJsZShzKSxpPW4mJnRoaXNbWl0obi5ieXRlcygpKXx8MDtyZXR1cm4gdy5pbmRleFRvQWRkcmVzcyhpKX1maW5hbGx5e3RoaXNbel0uZnJlZSh0KX19LHZhcl9zZXQ6KHQsZSk9PntsZXQgcz10aGlzLnJlYWQodCk7aWYocz09PW51bGwpe3RoaXMuI3MuZXJyb3IoYGF0dGVtcHRlZCB0byBzZXQgdmFyaWFibGUgdXNpbmcgaW52YWxpZCBrZXkgYWRkcmVzcyAoYWRkcj0iJHt0LnRvU3RyaW5nKDE2KX1IIilgKTtyZXR1cm59bGV0IG49cy5zdHJpbmcoKTtpZihlPT09MG4pe3RoaXMuZGVsZXRlVmFyaWFibGUobik7cmV0dXJufWxldCBpPXRoaXMuI3Rbdy5hZGRyZXNzVG9JbmRleChlKV07aWYoIWkpe3RoaXMuI3MuZXJyb3IoYGF0dGVtcHRlZCB0byBzZXQgdmFyaWFibGUgdG8gaW52YWxpZCBhZGRyZXNzIChrZXk9IiR7bn0iOyBhZGRyPSIke2UudG9TdHJpbmcoMTYpfUgiKWApO3JldHVybn10cnl7bGV0IG89bmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIuYnl0ZUxlbmd0aCk7by5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIpLDApLHRoaXMuc2V0VmFyaWFibGUobixvKX1jYXRjaChvKXt0aGlzLiNzLmVycm9yKG8ubWVzc2FnZSksdGhpcy5zZXRFcnJvcihvKTtyZXR1cm59fSxodHRwX3JlcXVlc3Q6KHQsZSk9Pih0aGlzLiNzLmVycm9yKCJodHRwX3JlcXVlc3QgaXMgbm90IGVuYWJsZWQiKSwwbiksaHR0cF9zdGF0dXNfY29kZTooKT0+KHRoaXMuI3MuZXJyb3IoImh0dHBfc3RhdHVzX2NvZGUgaXMgbm90IGVuYWJsZWQiKSwwKSxodHRwX2hlYWRlcnM6KCk9Pih0aGlzLiNzLmVycm9yKCJodHRwX2hlYWRlcnMgaXMgbm90IGVuYWJsZWQiKSwwbiksbGVuZ3RoOnQ9PnRoaXMubGVuZ3RoKHQpLGxlbmd0aF91bnNhZmU6dD0+dGhpcy5sZW5ndGgodCksbG9nX3dhcm46dGhpcy4jYS5iaW5kKHRoaXMsWCgid2FybiIpLCJ3YXJuIiksbG9nX2luZm86dGhpcy4jYS5iaW5kKHRoaXMsWCgiaW5mbyIpLCJpbmZvIiksbG9nX2RlYnVnOnRoaXMuI2EuYmluZCh0aGlzLFgoImRlYnVnIiksImRlYnVnIiksbG9nX2Vycm9yOnRoaXMuI2EuYmluZCh0aGlzLFgoImVycm9yIiksImVycm9yIiksbG9nX3RyYWNlOnRoaXMuI2EuYmluZCh0aGlzLFgoInRyYWNlIiksInRyYWNlIiksZ2V0X2xvZ19sZXZlbDooKT0+aXNGaW5pdGUodGhpcy4jbik/dGhpcy4jbjo0Mjk0OTY3Mjk1fTt0aGlzLiN1PXQsdGhpcy4jcz1lLHRoaXMuI249cz8/MjE0NzQ4MzY0Nyx0aGlzLiNsPW5ldyBUZXh0RGVjb2Rlcix0aGlzLiNyPW5ldyBUZXh0RW5jb2Rlcix0aGlzLiNvPWksdGhpcy4jaD0wLHRoaXMuI2U9W10sdGhpcy5hbGxvYygxKSx0aGlzLiNmPW59I2U7I3Q7I3M7I247I2w7I3I7I3U7I2Y7I2k7I2g7I287I2M7aG9zdENvbnRleHQoKXtyZXR1cm4gdGhpcy4jY31hbGxvYyh0KXtsZXQgZT1uZXcgdyhuZXcgdGhpcy4jdShOdW1iZXIodCkpLCEwKSxzPXRoaXMuI3QubGVuZ3RoO2lmKHRoaXMuI3QucHVzaChlKSx0aGlzLiNvLm1heFBhZ2VzKXtsZXQgaT10aGlzLiN0LnJlZHVjZSgoYSxsKT0+YSsobD8uYnVmZmVyLmJ5dGVMZW5ndGg/PzApLDApLG89TWF0aC5jZWlsKGkvNjU1MzYpO2lmKG8+dGhpcy4jby5tYXhQYWdlcylyZXR1cm4gdGhpcy4jcy5lcnJvcihgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkOiAke299IHBhZ2VzIHJlcXVlc3RlZCwgJHt0aGlzLiNvLm1heFBhZ2VzfSBhbGxvd2VkYCksMG59cmV0dXJuIHcuaW5kZXhUb0FkZHJlc3Mocyl9Z2V0VmFyaWFibGUodCl7cmV0dXJuIHRoaXMuI2kuaGFzKHQpP25ldyBqKHRoaXMuI2kuZ2V0KHQpLmJ1ZmZlcik6bnVsbH1zZXRWYXJpYWJsZSh0LGUpe2xldCBzPXR5cGVvZiBlPT0ic3RyaW5nIj90aGlzLiNyLmVuY29kZShlKTplLG49dGhpcy4jaS5nZXQodCksaT10aGlzLiNoK3MuYnl0ZUxlbmd0aC0obj8uYnl0ZUxlbmd0aHx8MCk7aWYoaT4odGhpcy4jbz8ubWF4VmFyQnl0ZXN8fDEvMCkpdGhyb3cgbmV3IEVycm9yKGB2YXIgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkOiAke2l9IGJ5dGVzIHJlcXVlc3RlZCwgJHt0aGlzLiNvLm1heFZhckJ5dGVzfSBhbGxvd2VkYCk7dGhpcy4jaD1pLHRoaXMuI2kuc2V0KHQscyl9ZGVsZXRlVmFyaWFibGUodCl7bGV0IGU9dGhpcy4jaS5nZXQodCk7IWV8fCh0aGlzLiNpLmRlbGV0ZSh0KSx0aGlzLiNoLT1lLmJ5dGVMZW5ndGgpfXJlYWQodCl7bGV0IGU9dy5hZGRyZXNzVG9JbmRleCh0KSxzPXRoaXMuI3RbZV07aWYoIXMpcmV0dXJuIG51bGw7bGV0IG49IShzLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSYmIWh0LmFsbG93U2hhcmVkQnVmZmVyQ29kZWM/bmV3IFVpbnQ4QXJyYXkocy5idWZmZXIpLnNsaWNlKCkuYnVmZmVyOnMuYnVmZmVyO3JldHVybiBuZXcgaihuKX1zdG9yZSh0KXtsZXQgZT10aGlzW1pdKHQpO2lmKCFlKXRocm93IG5ldyBFcnJvcigiZmFpbGVkIHRvIHN0b3JlIG91dHB1dCIpO3JldHVybiB3LmluZGV4VG9BZGRyZXNzKGUpfWxlbmd0aCh0KXtsZXQgZT13LmFkZHJlc3NUb0luZGV4KHQpLHM9dGhpcy4jdFtlXTtyZXR1cm4gcz9CaWdJbnQocy5idWZmZXIuYnl0ZUxlbmd0aCk6MG59c2V0RXJyb3IodD1udWxsKXtsZXQgZT10P3RoaXNbWl0odCBpbnN0YW5jZW9mIEVycm9yP3QubWVzc2FnZTp0KTowO2lmKCFlKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHN0b3JlIGVycm9yIHZhbHVlIik7dGhpcy4jZVt0aGlzLiNlLmxlbmd0aC0xXVsyXT1lfWdldCBsb2dMZXZlbCgpe3JldHVybiBEdCh0aGlzLiNuKX1zZXQgbG9nTGV2ZWwodCl7dGhpcy4jbj1YKHQpfSNhKHQsZSxzKXtsZXQgbj13LmFkZHJlc3NUb0luZGV4KHMpLGk9dGhpcy4jdFtuXTtpZighaSl7dGhpcy4jcy5lcnJvcihgZmFpbGVkIHRvIGxvZygke2V9KTogYmFkIGJsb2NrIHJlZmVyZW5jZSBpbiBhZGRyIDB4JHtzLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwiMCIpfWApO3JldHVybn10cnl7aWYodGhpcy4jbjw9dCl7bGV0IG89dGhpcy4jbC5kZWNvZGUoaS5idWZmZXIpO3RoaXMuI3NbZV0obyl9fWZpbmFsbHl7dGhpcy4jdFtuXT1udWxsfX1nZXQjcCgpe2xldCB0PXRoaXMuI2VbdGhpcy4jZS5sZW5ndGgtMV1bMF07cmV0dXJuIHQ9PT1udWxsP251bGw6dGhpcy4jdFt0XX1bKEllPXosZHQpXSgpe3RoaXMuI2M9bnVsbCx0aGlzLiN0Lmxlbmd0aD0xLHRoaXMuI2UubGVuZ3RoPTB9W1R0XSh0KXtsZXQgZT10aGlzLiN0W3RdO2lmKCFlKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBibG9jayBpbmRleDogJHt0fWApO3JldHVybiBlfVtmdF0odCxlPSExKXtmb3IobGV0W3Msbl1vZiB0LmJsb2Nrcyl7aWYocyYmZSl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkobmV3IHRoaXMuI3UoTnVtYmVyKHMuYnl0ZUxlbmd0aCkpKTtpLnNldChuZXcgVWludDhBcnJheShzKSkscz1pLmJ1ZmZlcn10aGlzLiN0W25dPXM/bmV3IHcocywhMSk6bnVsbH10aGlzLiNlPXQuc3RhY2t9W3B0XSgpe3JldHVybntzdGFjazp0aGlzLiNlLnNsaWNlKCksYmxvY2tzOnRoaXMuI3QubWFwKCh0LGUpPT50P3QubG9jYWw/KHQubG9jYWw9ITEsW3QuYnVmZmVyLGVdKTpudWxsOltudWxsLGVdKS5maWx0ZXIoQm9vbGVhbil9fVtaXSh0KXtpZih0eXBlb2YgdD09InN0cmluZyImJih0PXRoaXMuI3IuZW5jb2RlKHQpKSwhdClyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYodC5idWZmZXIuY29uc3RydWN0b3I9PT10aGlzLiN1JiZ0LmJ5dGVPZmZzZXQ9PT0wJiZ0LmJ5dGVMZW5ndGg9PT10LmJ1ZmZlci5ieXRlTGVuZ3RoKXtsZXQgaT10aGlzLiN0Lmxlbmd0aDtyZXR1cm4gdGhpcy4jdC5wdXNoKG5ldyB3KHQuYnVmZmVyLCEwKSksaX1sZXQgZT13LmFkZHJlc3NUb0luZGV4KHRoaXMuYWxsb2ModC5sZW5ndGgpKSxzPXRoaXMuI3RbZV07cmV0dXJuIG5ldyBVaW50OEFycmF5KHMuYnVmZmVyKS5zZXQodCwwKSxlfXJldHVybiB0fVtTdF0odCl7dGhpcy4jYz10fVtrdF0odCl7dGhpcy4jZS5wdXNoKFt0LG51bGwsbnVsbF0pfVtjdF0oKXt0aGlzLiNjPW51bGw7bGV0Wyx0LGVdPXRoaXMuI2UucG9wKCkscz1lPT09bnVsbD8xOjAsbj1lPz90LGk9W251bGwsbnVsbF07cmV0dXJuIG49PT1udWxsfHx0aGlzLiN0W25dPT09bnVsbHx8KGlbc109biksaX19O2ltcG9ydHtXQVNJIGFzIE1lfWZyb20id2FzaSI7aW1wb3J0e2Rldk51bGwgYXMgenR9ZnJvbSJub2RlOm9zIjtpbXBvcnR7b3BlbiBhcyBGdH1mcm9tIm5vZGU6ZnMvcHJvbWlzZXMiO2ltcG9ydHtjbG9zZVN5bmMgYXMgQ3R9ZnJvbSJub2RlOmZzIjthc3luYyBmdW5jdGlvbiBfZSgpe2xldFtyLHRdPWF3YWl0IFByb21pc2UuYWxsKFtGdCh6dCwiciIpLEZ0KHp0LCJ3IildKSxlPSEwLHM9YXN5bmMoKT0+e0N0KHIpLEN0KHQpfTtpZih0eXBlb2YgciE9Im51bWJlciIpe2xldCBuPW5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGk9Pnt0cnl7ZSYmQ3QoaSl9Y2F0Y2h7fX0pO24ucmVnaXN0ZXIocixyLmZkKSxuLnJlZ2lzdGVyKHQsdC5mZCkscz1hc3luYygpPT57ZT0hMSxhd2FpdCBQcm9taXNlLmFsbChbci5jbG9zZSgpLHQuY2xvc2UoKV0pLmNhdGNoKCgpPT57fSl9fXJldHVybntjbG9zZTpzLGZkczpbci5mZCx0LmZkLHQuZmRdfX1hc3luYyBmdW5jdGlvbiBIdChyLHQpe2xldHtjbG9zZTplLGZkczpbcyxuLGldfT10P3thc3luYyBjbG9zZSgpe30sZmRzOlswLDEsMl19OmF3YWl0IF9lKCksbz1uZXcgTWUoe3ZlcnNpb246InByZXZpZXcxIixwcmVvcGVuczpyLHN0ZGluOnMsc3Rkb3V0Om4sc3RkZXJyOml9KTtyZXR1cm57YXN5bmMgaW1wb3J0T2JqZWN0KCl7cmV0dXJuIG8ud2FzaUltcG9ydH0sYXN5bmMgY2xvc2UoKXthd2FpdCBlKCl9LGFzeW5jIGluaXRpYWxpemUoYSl7bGV0IGw9YS5leHBvcnRzLm1lbW9yeTtpZighbCl0aHJvdyBuZXcgRXJyb3IoIlRoZSBtb2R1bGUgaGFzIHRvIGV4cG9ydCBhIGRlZmF1bHQgbWVtb3J5LiIpO2lmKGEuZXhwb3J0cy5faW5pdGlhbGl6ZSl7bGV0IHU9YS5leHBvcnRzLl9pbml0aWFsaXplO28uaW5pdGlhbGl6ZT9vLmluaXRpYWxpemUoe2V4cG9ydHM6e21lbW9yeTpsLF9pbml0aWFsaXplOigpPT57dSgpfX19KTp1KCl9ZWxzZSBvLnN0YXJ0KHtleHBvcnRzOnttZW1vcnk6bCxfc3RhcnQ6KCk9Pnt9fX0pfX19dmFyIHBlPU9lKG5lKCksMSk7dmFyIGl0PXI9PntpZih0eXBlb2YgciE9InN0cmluZyIpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBwYXR0ZXJuIik7aWYoci5sZW5ndGg+NjU1MzYpdGhyb3cgbmV3IFR5cGVFcnJvcigicGF0dGVybiBpcyB0b28gbG9uZyIpfTt2YXIgVWU9eyJbOmFsbnVtOl0iOlsiXFxwe0x9XFxwe05sfVxccHtOZH0iLCEwXSwiWzphbHBoYTpdIjpbIlxccHtMfVxccHtObH0iLCEwXSwiWzphc2NpaTpdIjpbIlxceDAwLVxceDdmIiwhMV0sIls6Ymxhbms6XSI6WyJcXHB7WnN9XFx0IiwhMF0sIls6Y250cmw6XSI6WyJcXHB7Q2N9IiwhMF0sIls6ZGlnaXQ6XSI6WyJcXHB7TmR9IiwhMF0sIls6Z3JhcGg6XSI6WyJcXHB7Wn1cXHB7Q30iLCEwLCEwXSwiWzpsb3dlcjpdIjpbIlxccHtMbH0iLCEwXSwiWzpwcmludDpdIjpbIlxccHtDfSIsITBdLCJbOnB1bmN0Ol0iOlsiXFxwe1B9IiwhMF0sIls6c3BhY2U6XSI6WyJcXHB7Wn1cXHRcXHJcXG5cXHZcXGYiLCEwXSwiWzp1cHBlcjpdIjpbIlxccHtMdX0iLCEwXSwiWzp3b3JkOl0iOlsiXFxwe0x9XFxwe05sfVxccHtOZH1cXHB7UGN9IiwhMF0sIls6eGRpZ2l0Ol0iOlsiQS1GYS1mMC05IiwhMV19LG90PXI9PnIucmVwbGFjZSgvW1tcXVxcLV0vZywiXFwkJiIpLERlPXI9PnIucmVwbGFjZSgvWy1bXF17fSgpKis/LixcXF4kfCNcc10vZywiXFwkJiIpLHJlPXI9PnIuam9pbigiIiksaWU9KHIsdCk9PntsZXQgZT10O2lmKHIuY2hhckF0KGUpIT09IlsiKXRocm93IG5ldyBFcnJvcigibm90IGluIGEgYnJhY2UgZXhwcmVzc2lvbiIpO2xldCBzPVtdLG49W10saT1lKzEsbz0hMSxhPSExLGw9ITEsdT0hMSxjPWUsbT0iIjt0OmZvcig7aTxyLmxlbmd0aDspe2xldCBmPXIuY2hhckF0KGkpO2lmKChmPT09IiEifHxmPT09Il4iKSYmaT09PWUrMSl7dT0hMCxpKys7Y29udGludWV9aWYoZj09PSJdIiYmbyYmIWwpe2M9aSsxO2JyZWFrfWlmKG89ITAsZj09PSJcXCImJiFsKXtsPSEwLGkrKztjb250aW51ZX1pZihmPT09IlsiJiYhbCl7Zm9yKGxldFtnLFtiLEksU11db2YgT2JqZWN0LmVudHJpZXMoVWUpKWlmKHIuc3RhcnRzV2l0aChnLGkpKXtpZihtKXJldHVyblsiJC4iLCExLHIubGVuZ3RoLWUsITBdO2krPWcubGVuZ3RoLFM/bi5wdXNoKGIpOnMucHVzaChiKSxhPWF8fEk7Y29udGludWUgdH19aWYobD0hMSxtKXtmPm0/cy5wdXNoKG90KG0pKyItIitvdChmKSk6Zj09PW0mJnMucHVzaChvdChmKSksbT0iIixpKys7Y29udGludWV9aWYoci5zdGFydHNXaXRoKCItXSIsaSsxKSl7cy5wdXNoKG90KGYrIi0iKSksaSs9Mjtjb250aW51ZX1pZihyLnN0YXJ0c1dpdGgoIi0iLGkrMSkpe209ZixpKz0yO2NvbnRpbnVlfXMucHVzaChvdChmKSksaSsrfWlmKGM8aSlyZXR1cm5bIiIsITEsMCwhMV07aWYoIXMubGVuZ3RoJiYhbi5sZW5ndGgpcmV0dXJuWyIkLiIsITEsci5sZW5ndGgtZSwhMF07aWYobi5sZW5ndGg9PT0wJiZzLmxlbmd0aD09PTEmJi9eXFw/LiQvLnRlc3Qoc1swXSkmJiF1KXtsZXQgZj1zWzBdLmxlbmd0aD09PTI/c1swXS5zbGljZSgtMSk6c1swXTtyZXR1cm5bRGUoZiksITEsYy1lLCExXX1sZXQgcD0iWyIrKHU/Il4iOiIiKStyZShzKSsiXSIsZD0iWyIrKHU/IiI6Il4iKStyZShuKSsiXSI7cmV0dXJuW3MubGVuZ3RoJiZuLmxlbmd0aD8iKCIrcCsifCIrZCsiKSI6cy5sZW5ndGg/cDpkLGEsYy1lLCEwXX07dmFyIEY9KHIse3dpbmRvd3NQYXRoc05vRXNjYXBlOnQ9ITF9PXt9KT0+dD9yLnJlcGxhY2UoL1xbKFteXC9cXF0pXF0vZywiJDEiKTpyLnJlcGxhY2UoLygoPyFcXCkufF4pXFsoW15cL1xcXSlcXS9nLCIkMSQyIikucmVwbGFjZSgvXFwoW15cL10pL2csIiQxIik7dmFyIGplPW5ldyBTZXQoWyIhIiwiPyIsIisiLCIqIiwiQCJdKSxvZT1yPT5qZS5oYXMociksemU9Iig/ISg/Ol58LylcXC5cXC4/KD86JHwvKSkiLGd0PSIoPyFcXC4pIixGZT1uZXcgU2V0KFsiWyIsIi4iXSksSGU9bmV3IFNldChbIi4uIiwiLiJdKSxWZT1uZXcgU2V0KCIoKS4qe30rP1tdXiRcXCEiKSxHZT1yPT5yLnJlcGxhY2UoL1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csIlxcJCYiKSxfdD0iW14vXSIsYWU9X3QrIio/IixsZT1fdCsiKz8iLGssVCxCLHYsQSxILEosVixVLEssYXQsYnQsdWUsUSxtdCxsdCxNdCx5dCxoZSxfPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxzPXt9KXtFKHRoaXMsYnQpO0UodGhpcyxsdCk7VXQodGhpcywidHlwZSIpO0UodGhpcyxrLHZvaWQgMCk7RSh0aGlzLFQsdm9pZCAwKTtFKHRoaXMsQiwhMSk7RSh0aGlzLHYsW10pO0UodGhpcyxBLHZvaWQgMCk7RSh0aGlzLEgsdm9pZCAwKTtFKHRoaXMsSix2b2lkIDApO0UodGhpcyxWLCExKTtFKHRoaXMsVSx2b2lkIDApO0UodGhpcyxLLHZvaWQgMCk7RSh0aGlzLGF0LCExKTt0aGlzLnR5cGU9dCx0JiZ4KHRoaXMsVCwhMCkseCh0aGlzLEEsZSkseCh0aGlzLGssaCh0aGlzLEEpP2goaCh0aGlzLEEpLGspOnRoaXMpLHgodGhpcyxVLGgodGhpcyxrKT09PXRoaXM/czpoKGgodGhpcyxrKSxVKSkseCh0aGlzLEosaCh0aGlzLGspPT09dGhpcz9bXTpoKGgodGhpcyxrKSxKKSksdD09PSIhIiYmIWgoaCh0aGlzLGspLFYpJiZoKHRoaXMsSikucHVzaCh0aGlzKSx4KHRoaXMsSCxoKHRoaXMsQSk/aChoKHRoaXMsQSksdikubGVuZ3RoOjApfWdldCBoYXNNYWdpYygpe2lmKGgodGhpcyxUKSE9PXZvaWQgMClyZXR1cm4gaCh0aGlzLFQpO2ZvcihsZXQgdCBvZiBoKHRoaXMsdikpaWYodHlwZW9mIHQhPSJzdHJpbmciJiYodC50eXBlfHx0Lmhhc01hZ2ljKSlyZXR1cm4geCh0aGlzLFQsITApO3JldHVybiBoKHRoaXMsVCl9dG9TdHJpbmcoKXtyZXR1cm4gaCh0aGlzLEspIT09dm9pZCAwP2godGhpcyxLKTp0aGlzLnR5cGU/eCh0aGlzLEssdGhpcy50eXBlKyIoIitoKHRoaXMsdikubWFwKHQ9PlN0cmluZyh0KSkuam9pbigifCIpKyIpIik6eCh0aGlzLEssaCh0aGlzLHYpLm1hcCh0PT5TdHJpbmcodCkpLmpvaW4oIiIpKX1wdXNoKC4uLnQpe2ZvcihsZXQgZSBvZiB0KWlmKGUhPT0iIil7aWYodHlwZW9mIGUhPSJzdHJpbmciJiYhKGUgaW5zdGFuY2VvZiBfJiZoKGUsQSk9PT10aGlzKSl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgcGFydDogIitlKTtoKHRoaXMsdikucHVzaChlKX19dG9KU09OKCl7bGV0IHQ9dGhpcy50eXBlPT09bnVsbD9oKHRoaXMsdikuc2xpY2UoKS5tYXAoZT0+dHlwZW9mIGU9PSJzdHJpbmciP2U6ZS50b0pTT04oKSk6W3RoaXMudHlwZSwuLi5oKHRoaXMsdikubWFwKGU9PmUudG9KU09OKCkpXTtyZXR1cm4gdGhpcy5pc1N0YXJ0KCkmJiF0aGlzLnR5cGUmJnQudW5zaGlmdChbXSksdGhpcy5pc0VuZCgpJiYodGhpcz09PWgodGhpcyxrKXx8aChoKHRoaXMsayksVikmJmgodGhpcyxBKT8udHlwZT09PSIhIikmJnQucHVzaCh7fSksdH1pc1N0YXJ0KCl7aWYoaCh0aGlzLGspPT09dGhpcylyZXR1cm4hMDtpZighaCh0aGlzLEEpPy5pc1N0YXJ0KCkpcmV0dXJuITE7aWYoaCh0aGlzLEgpPT09MClyZXR1cm4hMDtsZXQgdD1oKHRoaXMsQSk7Zm9yKGxldCBlPTA7ZTxoKHRoaXMsSCk7ZSsrKXtsZXQgcz1oKHQsdilbZV07aWYoIShzIGluc3RhbmNlb2YgXyYmcy50eXBlPT09IiEiKSlyZXR1cm4hMX1yZXR1cm4hMH1pc0VuZCgpe2lmKGgodGhpcyxrKT09PXRoaXN8fGgodGhpcyxBKT8udHlwZT09PSIhIilyZXR1cm4hMDtpZighaCh0aGlzLEEpPy5pc0VuZCgpKXJldHVybiExO2lmKCF0aGlzLnR5cGUpcmV0dXJuIGgodGhpcyxBKT8uaXNFbmQoKTtsZXQgdD1oKHRoaXMsQSk/aChoKHRoaXMsQSksdikubGVuZ3RoOjA7cmV0dXJuIGgodGhpcyxIKT09PXQtMX1jb3B5SW4odCl7dHlwZW9mIHQ9PSJzdHJpbmciP3RoaXMucHVzaCh0KTp0aGlzLnB1c2godC5jbG9uZSh0aGlzKSl9Y2xvbmUodCl7bGV0IGU9bmV3IF8odGhpcy50eXBlLHQpO2ZvcihsZXQgcyBvZiBoKHRoaXMsdikpZS5jb3B5SW4ocyk7cmV0dXJuIGV9c3RhdGljIGZyb21HbG9iKHQsZT17fSl7dmFyIG47bGV0IHM9bmV3IF8obnVsbCx2b2lkIDAsZSk7cmV0dXJuIEQobj1fLFEsbXQpLmNhbGwobix0LHMsMCxlKSxzfXRvTU1QYXR0ZXJuKCl7aWYodGhpcyE9PWgodGhpcyxrKSlyZXR1cm4gaCh0aGlzLGspLnRvTU1QYXR0ZXJuKCk7bGV0IHQ9dGhpcy50b1N0cmluZygpLFtlLHMsbixpXT10aGlzLnRvUmVnRXhwU291cmNlKCk7aWYoIShufHxoKHRoaXMsVCl8fGgodGhpcyxVKS5ub2Nhc2UmJiFoKHRoaXMsVSkubm9jYXNlTWFnaWNPbmx5JiZ0LnRvVXBwZXJDYXNlKCkhPT10LnRvTG93ZXJDYXNlKCkpKXJldHVybiBzO2xldCBhPShoKHRoaXMsVSkubm9jYXNlPyJpIjoiIikrKGk/InUiOiIiKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUmVnRXhwKGBeJHtlfSRgLGEpLHtfc3JjOmUsX2dsb2I6dH0pfXRvUmVnRXhwU291cmNlKHQpe2xldCBlPXQ/PyEhaCh0aGlzLFUpLmRvdDtpZihoKHRoaXMsayk9PT10aGlzJiZEKHRoaXMsYnQsdWUpLmNhbGwodGhpcyksIXRoaXMudHlwZSl7bGV0IGw9dGhpcy5pc1N0YXJ0KCkmJnRoaXMuaXNFbmQoKSx1PWgodGhpcyx2KS5tYXAoZD0+e3ZhciBJO2xldFt5LGYsZyxiXT10eXBlb2YgZD09InN0cmluZyI/RChJPV8seXQsaGUpLmNhbGwoSSxkLGgodGhpcyxUKSxsKTpkLnRvUmVnRXhwU291cmNlKHQpO3JldHVybiB4KHRoaXMsVCxoKHRoaXMsVCl8fGcpLHgodGhpcyxCLGgodGhpcyxCKXx8YikseX0pLmpvaW4oIiIpLGM9IiI7aWYodGhpcy5pc1N0YXJ0KCkmJnR5cGVvZiBoKHRoaXMsdilbMF09PSJzdHJpbmciJiYhKGgodGhpcyx2KS5sZW5ndGg9PT0xJiZIZS5oYXMoaCh0aGlzLHYpWzBdKSkpe2xldCB5PUZlLGY9ZSYmeS5oYXModS5jaGFyQXQoMCkpfHx1LnN0YXJ0c1dpdGgoIlxcLiIpJiZ5Lmhhcyh1LmNoYXJBdCgyKSl8fHUuc3RhcnRzV2l0aCgiXFwuXFwuIikmJnkuaGFzKHUuY2hhckF0KDQpKSxnPSFlJiYhdCYmeS5oYXModS5jaGFyQXQoMCkpO2M9Zj96ZTpnP2d0OiIifWxldCBtPSIiO3JldHVybiB0aGlzLmlzRW5kKCkmJmgoaCh0aGlzLGspLFYpJiZoKHRoaXMsQSk/LnR5cGU9PT0iISImJihtPSIoPzokfFxcLykiKSxbYyt1K20sRih1KSx4KHRoaXMsVCwhIWgodGhpcyxUKSksaCh0aGlzLEIpXX1sZXQgcz10aGlzLnR5cGU9PT0iKiJ8fHRoaXMudHlwZT09PSIrIixuPXRoaXMudHlwZT09PSIhIj8iKD86KD8hKD86IjoiKD86IixpPUQodGhpcyxsdCxNdCkuY2FsbCh0aGlzLGUpO2lmKHRoaXMuaXNTdGFydCgpJiZ0aGlzLmlzRW5kKCkmJiFpJiZ0aGlzLnR5cGUhPT0iISIpe2xldCBsPXRoaXMudG9TdHJpbmcoKTtyZXR1cm4geCh0aGlzLHYsW2xdKSx0aGlzLnR5cGU9bnVsbCx4KHRoaXMsVCx2b2lkIDApLFtsLEYodGhpcy50b1N0cmluZygpKSwhMSwhMV19bGV0IG89IXN8fHR8fGV8fCFndD8iIjpEKHRoaXMsbHQsTXQpLmNhbGwodGhpcywhMCk7bz09PWkmJihvPSIiKSxvJiYoaT1gKD86JHtpfSkoPzoke299KSo/YCk7bGV0IGE9IiI7aWYodGhpcy50eXBlPT09IiEiJiZoKHRoaXMsYXQpKWE9KHRoaXMuaXNTdGFydCgpJiYhZT9ndDoiIikrbGU7ZWxzZXtsZXQgbD10aGlzLnR5cGU9PT0iISI/IikpIisodGhpcy5pc1N0YXJ0KCkmJiFlJiYhdD9ndDoiIikrYWUrIikiOnRoaXMudHlwZT09PSJAIj8iKSI6dGhpcy50eXBlPT09Ij8iPyIpPyI6dGhpcy50eXBlPT09IisiJiZvPyIpIjp0aGlzLnR5cGU9PT0iKiImJm8/Iik/IjpgKSR7dGhpcy50eXBlfWA7YT1uK2krbH1yZXR1cm5bYSxGKGkpLHgodGhpcyxULCEhaCh0aGlzLFQpKSxoKHRoaXMsQildfX0sRz1fO2s9bmV3IFdlYWtNYXAsVD1uZXcgV2Vha01hcCxCPW5ldyBXZWFrTWFwLHY9bmV3IFdlYWtNYXAsQT1uZXcgV2Vha01hcCxIPW5ldyBXZWFrTWFwLEo9bmV3IFdlYWtNYXAsVj1uZXcgV2Vha01hcCxVPW5ldyBXZWFrTWFwLEs9bmV3IFdlYWtNYXAsYXQ9bmV3IFdlYWtNYXAsYnQ9bmV3IFdlYWtTZXQsdWU9ZnVuY3Rpb24oKXtpZih0aGlzIT09aCh0aGlzLGspKXRocm93IG5ldyBFcnJvcigic2hvdWxkIG9ubHkgY2FsbCBvbiByb290Iik7aWYoaCh0aGlzLFYpKXJldHVybiB0aGlzO3RoaXMudG9TdHJpbmcoKSx4KHRoaXMsViwhMCk7bGV0IHQ7Zm9yKDt0PWgodGhpcyxKKS5wb3AoKTspe2lmKHQudHlwZSE9PSIhIiljb250aW51ZTtsZXQgZT10LHM9aChlLEEpO2Zvcig7czspe2ZvcihsZXQgbj1oKGUsSCkrMTshcy50eXBlJiZuPGgocyx2KS5sZW5ndGg7bisrKWZvcihsZXQgaSBvZiBoKHQsdikpe2lmKHR5cGVvZiBpPT0ic3RyaW5nIil0aHJvdyBuZXcgRXJyb3IoInN0cmluZyBwYXJ0IGluIGV4dGdsb2IgQVNUPz8iKTtpLmNvcHlJbihoKHMsdilbbl0pfWU9cyxzPWgoZSxBKX19cmV0dXJuIHRoaXN9LFE9bmV3IFdlYWtTZXQsbXQ9ZnVuY3Rpb24odCxlLHMsbil7dmFyIGQseTtsZXQgaT0hMSxvPSExLGE9LTEsbD0hMTtpZihlLnR5cGU9PT1udWxsKXtsZXQgZj1zLGc9IiI7Zm9yKDtmPHQubGVuZ3RoOyl7bGV0IGI9dC5jaGFyQXQoZisrKTtpZihpfHxiPT09IlxcIil7aT0haSxnKz1iO2NvbnRpbnVlfWlmKG8pe2Y9PT1hKzE/KGI9PT0iXiJ8fGI9PT0iISIpJiYobD0hMCk6Yj09PSJdIiYmIShmPT09YSsyJiZsKSYmKG89ITEpLGcrPWI7Y29udGludWV9ZWxzZSBpZihiPT09IlsiKXtvPSEwLGE9ZixsPSExLGcrPWI7Y29udGludWV9aWYoIW4ubm9leHQmJm9lKGIpJiZ0LmNoYXJBdChmKT09PSIoIil7ZS5wdXNoKGcpLGc9IiI7bGV0IEk9bmV3IF8oYixlKTtmPUQoZD1fLFEsbXQpLmNhbGwoZCx0LEksZixuKSxlLnB1c2goSSk7Y29udGludWV9Zys9Yn1yZXR1cm4gZS5wdXNoKGcpLGZ9bGV0IHU9cysxLGM9bmV3IF8obnVsbCxlKSxtPVtdLHA9IiI7Zm9yKDt1PHQubGVuZ3RoOyl7bGV0IGY9dC5jaGFyQXQodSsrKTtpZihpfHxmPT09IlxcIil7aT0haSxwKz1mO2NvbnRpbnVlfWlmKG8pe3U9PT1hKzE/KGY9PT0iXiJ8fGY9PT0iISIpJiYobD0hMCk6Zj09PSJdIiYmISh1PT09YSsyJiZsKSYmKG89ITEpLHArPWY7Y29udGludWV9ZWxzZSBpZihmPT09IlsiKXtvPSEwLGE9dSxsPSExLHArPWY7Y29udGludWV9aWYob2UoZikmJnQuY2hhckF0KHUpPT09IigiKXtjLnB1c2gocCkscD0iIjtsZXQgZz1uZXcgXyhmLGMpO2MucHVzaChnKSx1PUQoeT1fLFEsbXQpLmNhbGwoeSx0LGcsdSxuKTtjb250aW51ZX1pZihmPT09InwiKXtjLnB1c2gocCkscD0iIixtLnB1c2goYyksYz1uZXcgXyhudWxsLGUpO2NvbnRpbnVlfWlmKGY9PT0iKSIpcmV0dXJuIHA9PT0iIiYmaChlLHYpLmxlbmd0aD09PTAmJngoZSxhdCwhMCksYy5wdXNoKHApLHA9IiIsZS5wdXNoKC4uLm0sYyksdTtwKz1mfXJldHVybiBlLnR5cGU9bnVsbCx4KGUsVCx2b2lkIDApLHgoZSx2LFt0LnN1YnN0cmluZyhzLTEpXSksdX0sbHQ9bmV3IFdlYWtTZXQsTXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGgodGhpcyx2KS5tYXAoZT0+e2lmKHR5cGVvZiBlPT0ic3RyaW5nIil0aHJvdyBuZXcgRXJyb3IoInN0cmluZyB0eXBlIGluIGV4dGdsb2IgYXN0Pz8iKTtsZXRbcyxuLGksb109ZS50b1JlZ0V4cFNvdXJjZSh0KTtyZXR1cm4geCh0aGlzLEIsaCh0aGlzLEIpfHxvKSxzfSkuZmlsdGVyKGU9PiEodGhpcy5pc1N0YXJ0KCkmJnRoaXMuaXNFbmQoKSl8fCEhZSkuam9pbigifCIpfSx5dD1uZXcgV2Vha1NldCxoZT1mdW5jdGlvbih0LGUscz0hMSl7bGV0IG49ITEsaT0iIixvPSExO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXtsZXQgbD10LmNoYXJBdChhKTtpZihuKXtuPSExLGkrPShWZS5oYXMobCk/IlxcIjoiIikrbDtjb250aW51ZX1pZihsPT09IlxcIil7YT09PXQubGVuZ3RoLTE/aSs9IlxcXFwiOm49ITA7Y29udGludWV9aWYobD09PSJbIil7bGV0W3UsYyxtLHBdPWllKHQsYSk7aWYobSl7aSs9dSxvPW98fGMsYSs9bS0xLGU9ZXx8cDtjb250aW51ZX19aWYobD09PSIqIil7cyYmdD09PSIqIj9pKz1sZTppKz1hZSxlPSEwO2NvbnRpbnVlfWlmKGw9PT0iPyIpe2krPV90LGU9ITA7Y29udGludWV9aSs9R2UobCl9cmV0dXJuW2ksRih0KSwhIWUsb119LEUoRyxRKSxFKEcseXQpO3ZhciBMdD0ocix7d2luZG93c1BhdGhzTm9Fc2NhcGU6dD0hMX09e30pPT50P3IucmVwbGFjZSgvWz8qKClbXF1dL2csIlskJl0iKTpyLnJlcGxhY2UoL1s/KigpW1xdXFxdL2csIlxcJCYiKTt2YXIgTz0ocix0LGU9e30pPT4oaXQodCksIWUubm9jb21tZW50JiZ0LmNoYXJBdCgwKT09PSIjIj8hMTpuZXcgdHQodCxlKS5tYXRjaChyKSkscWU9L15cKisoW14rQCE/XCpcW1woXSopJC8sWGU9cj0+dD0+IXQuc3RhcnRzV2l0aCgiLiIpJiZ0LmVuZHNXaXRoKHIpLEplPXI9PnQ9PnQuZW5kc1dpdGgociksS2U9cj0+KHI9ci50b0xvd2VyQ2FzZSgpLHQ9PiF0LnN0YXJ0c1dpdGgoIi4iKSYmdC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKHIpKSxaZT1yPT4ocj1yLnRvTG93ZXJDYXNlKCksdD0+dC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKHIpKSxZZT0vXlwqK1wuXCorJC8sUWU9cj0+IXIuc3RhcnRzV2l0aCgiLiIpJiZyLmluY2x1ZGVzKCIuIiksdHM9cj0+ciE9PSIuIiYmciE9PSIuLiImJnIuaW5jbHVkZXMoIi4iKSxlcz0vXlwuXCorJC8sc3M9cj0+ciE9PSIuIiYmciE9PSIuLiImJnIuc3RhcnRzV2l0aCgiLiIpLG5zPS9eXCorJC8scnM9cj0+ci5sZW5ndGghPT0wJiYhci5zdGFydHNXaXRoKCIuIiksaXM9cj0+ci5sZW5ndGghPT0wJiZyIT09Ii4iJiZyIT09Ii4uIixvcz0vXlw/KyhbXitAIT9cKlxbXChdKik/JC8sYXM9KFtyLHQ9IiJdKT0+e2xldCBlPWRlKFtyXSk7cmV0dXJuIHQ/KHQ9dC50b0xvd2VyQ2FzZSgpLHM9PmUocykmJnMudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCh0KSk6ZX0sbHM9KFtyLHQ9IiJdKT0+e2xldCBlPWdlKFtyXSk7cmV0dXJuIHQ/KHQ9dC50b0xvd2VyQ2FzZSgpLHM9PmUocykmJnMudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCh0KSk6ZX0sdXM9KFtyLHQ9IiJdKT0+e2xldCBlPWdlKFtyXSk7cmV0dXJuIHQ/cz0+ZShzKSYmcy5lbmRzV2l0aCh0KTplfSxocz0oW3IsdD0iIl0pPT57bGV0IGU9ZGUoW3JdKTtyZXR1cm4gdD9zPT5lKHMpJiZzLmVuZHNXaXRoKHQpOmV9LGRlPShbcl0pPT57bGV0IHQ9ci5sZW5ndGg7cmV0dXJuIGU9PmUubGVuZ3RoPT09dCYmIWUuc3RhcnRzV2l0aCgiLiIpfSxnZT0oW3JdKT0+e2xldCB0PXIubGVuZ3RoO3JldHVybiBlPT5lLmxlbmd0aD09PXQmJmUhPT0iLiImJmUhPT0iLi4ifSxtZT10eXBlb2YgcHJvY2Vzcz09Im9iamVjdCImJnByb2Nlc3M/dHlwZW9mIHByb2Nlc3MuZW52PT0ib2JqZWN0IiYmcHJvY2Vzcy5lbnYmJnByb2Nlc3MuZW52Ll9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fX3x8cHJvY2Vzcy5wbGF0Zm9ybToicG9zaXgiLGNlPXt3aW4zMjp7c2VwOiJcXCJ9LHBvc2l4OntzZXA6Ii8ifX0sY3M9bWU9PT0id2luMzIiP2NlLndpbjMyLnNlcDpjZS5wb3NpeC5zZXA7Ty5zZXA9Y3M7dmFyIFc9U3ltYm9sKCJnbG9ic3RhciAqKiIpO08uR0xPQlNUQVI9Vzt2YXIgZnM9IlteL10iLHBzPWZzKyIqPyIsZHM9Iig/Oig/ISg/OlxcL3xeKSg/OlxcLnsxLDJ9KSgkfFxcLykpLikqPyIsZ3M9Iig/Oig/ISg/OlxcL3xeKVxcLikuKSo/Iixtcz0ocix0PXt9KT0+ZT0+TyhlLHIsdCk7Ty5maWx0ZXI9bXM7dmFyIFA9KHIsdD17fSk9Pk9iamVjdC5hc3NpZ24oe30scix0KSxicz1yPT57aWYoIXJ8fHR5cGVvZiByIT0ib2JqZWN0Inx8IU9iamVjdC5rZXlzKHIpLmxlbmd0aClyZXR1cm4gTztsZXQgdD1PO3JldHVybiBPYmplY3QuYXNzaWduKChzLG4saT17fSk9PnQocyxuLFAocixpKSkse01pbmltYXRjaDpjbGFzcyBleHRlbmRzIHQuTWluaW1hdGNoe2NvbnN0cnVjdG9yKG4saT17fSl7c3VwZXIobixQKHIsaSkpfXN0YXRpYyBkZWZhdWx0cyhuKXtyZXR1cm4gdC5kZWZhdWx0cyhQKHIsbikpLk1pbmltYXRjaH19LEFTVDpjbGFzcyBleHRlbmRzIHQuQVNUe2NvbnN0cnVjdG9yKG4saSxvPXt9KXtzdXBlcihuLGksUChyLG8pKX1zdGF0aWMgZnJvbUdsb2IobixpPXt9KXtyZXR1cm4gdC5BU1QuZnJvbUdsb2IobixQKHIsaSkpfX0sdW5lc2NhcGU6KHMsbj17fSk9PnQudW5lc2NhcGUocyxQKHIsbikpLGVzY2FwZToocyxuPXt9KT0+dC5lc2NhcGUocyxQKHIsbikpLGZpbHRlcjoocyxuPXt9KT0+dC5maWx0ZXIocyxQKHIsbikpLGRlZmF1bHRzOnM9PnQuZGVmYXVsdHMoUChyLHMpKSxtYWtlUmU6KHMsbj17fSk9PnQubWFrZVJlKHMsUChyLG4pKSxicmFjZUV4cGFuZDoocyxuPXt9KT0+dC5icmFjZUV4cGFuZChzLFAocixuKSksbWF0Y2g6KHMsbixpPXt9KT0+dC5tYXRjaChzLG4sUChyLGkpKSxzZXA6dC5zZXAsR0xPQlNUQVI6V30pfTtPLmRlZmF1bHRzPWJzO3ZhciBiZT0ocix0PXt9KT0+KGl0KHIpLHQubm9icmFjZXx8IS9ceyg/Oig/IVx7KS4pKlx9Ly50ZXN0KHIpP1tyXTooMCxwZS5kZWZhdWx0KShyKSk7Ty5icmFjZUV4cGFuZD1iZTt2YXIgeXM9KHIsdD17fSk9Pm5ldyB0dChyLHQpLm1ha2VSZSgpO08ubWFrZVJlPXlzO3ZhciB3cz0ocix0LGU9e30pPT57bGV0IHM9bmV3IHR0KHQsZSk7cmV0dXJuIHI9ci5maWx0ZXIobj0+cy5tYXRjaChuKSkscy5vcHRpb25zLm5vbnVsbCYmIXIubGVuZ3RoJiZyLnB1c2godCkscn07Ty5tYXRjaD13czt2YXIgZmU9L1s/Kl18WytAIV1cKC4qP1wpfFxbfFxdLyx4cz1yPT5yLnJlcGxhY2UoL1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csIlxcJCYiKSx0dD1jbGFzc3tvcHRpb25zO3NldDtwYXR0ZXJuO3dpbmRvd3NQYXRoc05vRXNjYXBlO25vbmVnYXRlO25lZ2F0ZTtjb21tZW50O2VtcHR5O3ByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO3BhcnRpYWw7Z2xvYlNldDtnbG9iUGFydHM7bm9jYXNlO2lzV2luZG93cztwbGF0Zm9ybTt3aW5kb3dzTm9NYWdpY1Jvb3Q7cmVnZXhwO2NvbnN0cnVjdG9yKHQsZT17fSl7aXQodCksZT1lfHx7fSx0aGlzLm9wdGlvbnM9ZSx0aGlzLnBhdHRlcm49dCx0aGlzLnBsYXRmb3JtPWUucGxhdGZvcm18fG1lLHRoaXMuaXNXaW5kb3dzPXRoaXMucGxhdGZvcm09PT0id2luMzIiLHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGU9ISFlLndpbmRvd3NQYXRoc05vRXNjYXBlfHxlLmFsbG93V2luZG93c0VzY2FwZT09PSExLHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUmJih0aGlzLnBhdHRlcm49dGhpcy5wYXR0ZXJuLnJlcGxhY2UoL1xcL2csIi8iKSksdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcz0hIWUucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMsdGhpcy5yZWdleHA9bnVsbCx0aGlzLm5lZ2F0ZT0hMSx0aGlzLm5vbmVnYXRlPSEhZS5ub25lZ2F0ZSx0aGlzLmNvbW1lbnQ9ITEsdGhpcy5lbXB0eT0hMSx0aGlzLnBhcnRpYWw9ISFlLnBhcnRpYWwsdGhpcy5ub2Nhc2U9ISF0aGlzLm9wdGlvbnMubm9jYXNlLHRoaXMud2luZG93c05vTWFnaWNSb290PWUud2luZG93c05vTWFnaWNSb290IT09dm9pZCAwP2Uud2luZG93c05vTWFnaWNSb290OiEhKHRoaXMuaXNXaW5kb3dzJiZ0aGlzLm5vY2FzZSksdGhpcy5nbG9iU2V0PVtdLHRoaXMuZ2xvYlBhcnRzPVtdLHRoaXMuc2V0PVtdLHRoaXMubWFrZSgpfWhhc01hZ2ljKCl7aWYodGhpcy5vcHRpb25zLm1hZ2ljYWxCcmFjZXMmJnRoaXMuc2V0Lmxlbmd0aD4xKXJldHVybiEwO2ZvcihsZXQgdCBvZiB0aGlzLnNldClmb3IobGV0IGUgb2YgdClpZih0eXBlb2YgZSE9InN0cmluZyIpcmV0dXJuITA7cmV0dXJuITF9ZGVidWcoLi4udCl7fW1ha2UoKXtsZXQgdD10aGlzLnBhdHRlcm4sZT10aGlzLm9wdGlvbnM7aWYoIWUubm9jb21tZW50JiZ0LmNoYXJBdCgwKT09PSIjIil7dGhpcy5jb21tZW50PSEwO3JldHVybn1pZighdCl7dGhpcy5lbXB0eT0hMDtyZXR1cm59dGhpcy5wYXJzZU5lZ2F0ZSgpLHRoaXMuZ2xvYlNldD1bLi4ubmV3IFNldCh0aGlzLmJyYWNlRXhwYW5kKCkpXSxlLmRlYnVnJiYodGhpcy5kZWJ1Zz0oLi4uaSk9PmNvbnNvbGUuZXJyb3IoLi4uaSkpLHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLHRoaXMuZ2xvYlNldCk7bGV0IHM9dGhpcy5nbG9iU2V0Lm1hcChpPT50aGlzLnNsYXNoU3BsaXQoaSkpO3RoaXMuZ2xvYlBhcnRzPXRoaXMucHJlcHJvY2VzcyhzKSx0aGlzLmRlYnVnKHRoaXMucGF0dGVybix0aGlzLmdsb2JQYXJ0cyk7bGV0IG49dGhpcy5nbG9iUGFydHMubWFwKChpLG8sYSk9PntpZih0aGlzLmlzV2luZG93cyYmdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3Qpe2xldCBsPWlbMF09PT0iIiYmaVsxXT09PSIiJiYoaVsyXT09PSI/Inx8IWZlLnRlc3QoaVsyXSkpJiYhZmUudGVzdChpWzNdKSx1PS9eW2Etel06L2kudGVzdChpWzBdKTtpZihsKXJldHVyblsuLi5pLnNsaWNlKDAsNCksLi4uaS5zbGljZSg0KS5tYXAoYz0+dGhpcy5wYXJzZShjKSldO2lmKHUpcmV0dXJuW2lbMF0sLi4uaS5zbGljZSgxKS5tYXAoYz0+dGhpcy5wYXJzZShjKSldfXJldHVybiBpLm1hcChsPT50aGlzLnBhcnNlKGwpKX0pO2lmKHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLG4pLHRoaXMuc2V0PW4uZmlsdGVyKGk9PmkuaW5kZXhPZighMSk9PT0tMSksdGhpcy5pc1dpbmRvd3MpZm9yKGxldCBpPTA7aTx0aGlzLnNldC5sZW5ndGg7aSsrKXtsZXQgbz10aGlzLnNldFtpXTtvWzBdPT09IiImJm9bMV09PT0iIiYmdGhpcy5nbG9iUGFydHNbaV1bMl09PT0iPyImJnR5cGVvZiBvWzNdPT0ic3RyaW5nIiYmL15bYS16XTokL2kudGVzdChvWzNdKSYmKG9bMl09Ij8iKX10aGlzLmRlYnVnKHRoaXMucGF0dGVybix0aGlzLnNldCl9cHJlcHJvY2Vzcyh0KXtpZih0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcilmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylmb3IobGV0IG49MDtuPHRbc10ubGVuZ3RoO24rKyl0W3NdW25dPT09IioqIiYmKHRbc11bbl09IioiKTtsZXR7b3B0aW1pemF0aW9uTGV2ZWw6ZT0xfT10aGlzLm9wdGlvbnM7cmV0dXJuIGU+PTI/KHQ9dGhpcy5maXJzdFBoYXNlUHJlUHJvY2Vzcyh0KSx0PXRoaXMuc2Vjb25kUGhhc2VQcmVQcm9jZXNzKHQpKTplPj0xP3Q9dGhpcy5sZXZlbE9uZU9wdGltaXplKHQpOnQ9dGhpcy5hZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKHQpLHR9YWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZSh0KXtyZXR1cm4gdC5tYXAoZT0+e2xldCBzPS0xO2Zvcig7KHM9ZS5pbmRleE9mKCIqKiIscysxKSkhPT0tMTspe2xldCBuPXM7Zm9yKDtlW24rMV09PT0iKioiOyluKys7biE9PXMmJmUuc3BsaWNlKHMsbi1zKX1yZXR1cm4gZX0pfWxldmVsT25lT3B0aW1pemUodCl7cmV0dXJuIHQubWFwKGU9PihlPWUucmVkdWNlKChzLG4pPT57bGV0IGk9c1tzLmxlbmd0aC0xXTtyZXR1cm4gbj09PSIqKiImJmk9PT0iKioiP3M6bj09PSIuLiImJmkmJmkhPT0iLi4iJiZpIT09Ii4iJiZpIT09IioqIj8ocy5wb3AoKSxzKToocy5wdXNoKG4pLHMpfSxbXSksZS5sZW5ndGg9PT0wP1siIl06ZSkpfWxldmVsVHdvRmlsZU9wdGltaXplKHQpe0FycmF5LmlzQXJyYXkodCl8fCh0PXRoaXMuc2xhc2hTcGxpdCh0KSk7bGV0IGU9ITE7ZG97aWYoZT0hMSwhdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyl7Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aC0xO24rKyl7bGV0IGk9dFtuXTtuPT09MSYmaT09PSIiJiZ0WzBdPT09IiJ8fChpPT09Ii4ifHxpPT09IiIpJiYoZT0hMCx0LnNwbGljZShuLDEpLG4tLSl9dFswXT09PSIuIiYmdC5sZW5ndGg9PT0yJiYodFsxXT09PSIuInx8dFsxXT09PSIiKSYmKGU9ITAsdC5wb3AoKSl9bGV0IHM9MDtmb3IoOyhzPXQuaW5kZXhPZigiLi4iLHMrMSkpIT09LTE7KXtsZXQgbj10W3MtMV07biYmbiE9PSIuIiYmbiE9PSIuLiImJm4hPT0iKioiJiYoZT0hMCx0LnNwbGljZShzLTEsMikscy09Mil9fXdoaWxlKGUpO3JldHVybiB0Lmxlbmd0aD09PTA/WyIiXTp0fWZpcnN0UGhhc2VQcmVQcm9jZXNzKHQpe2xldCBlPSExO2Rve2U9ITE7Zm9yKGxldCBzIG9mIHQpe2xldCBuPS0xO2Zvcig7KG49cy5pbmRleE9mKCIqKiIsbisxKSkhPT0tMTspe2xldCBvPW47Zm9yKDtzW28rMV09PT0iKioiOylvKys7bz5uJiZzLnNwbGljZShuKzEsby1uKTtsZXQgYT1zW24rMV0sbD1zW24rMl0sdT1zW24rM107aWYoYSE9PSIuLiJ8fCFsfHxsPT09Ii4ifHxsPT09Ii4uInx8IXV8fHU9PT0iLiJ8fHU9PT0iLi4iKWNvbnRpbnVlO2U9ITAscy5zcGxpY2UobiwxKTtsZXQgYz1zLnNsaWNlKDApO2Nbbl09IioqIix0LnB1c2goYyksbi0tfWlmKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKXtmb3IobGV0IG89MTtvPHMubGVuZ3RoLTE7bysrKXtsZXQgYT1zW29dO289PT0xJiZhPT09IiImJnNbMF09PT0iInx8KGE9PT0iLiJ8fGE9PT0iIikmJihlPSEwLHMuc3BsaWNlKG8sMSksby0tKX1zWzBdPT09Ii4iJiZzLmxlbmd0aD09PTImJihzWzFdPT09Ii4ifHxzWzFdPT09IiIpJiYoZT0hMCxzLnBvcCgpKX1sZXQgaT0wO2Zvcig7KGk9cy5pbmRleE9mKCIuLiIsaSsxKSkhPT0tMTspe2xldCBvPXNbaS0xXTtpZihvJiZvIT09Ii4iJiZvIT09Ii4uIiYmbyE9PSIqKiIpe2U9ITA7bGV0IGw9aT09PTEmJnNbaSsxXT09PSIqKiI/WyIuIl06W107cy5zcGxpY2UoaS0xLDIsLi4ubCkscy5sZW5ndGg9PT0wJiZzLnB1c2goIiIpLGktPTJ9fX19d2hpbGUoZSk7cmV0dXJuIHR9c2Vjb25kUGhhc2VQcmVQcm9jZXNzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspZm9yKGxldCBzPWUrMTtzPHQubGVuZ3RoO3MrKyl7bGV0IG49dGhpcy5wYXJ0c01hdGNoKHRbZV0sdFtzXSwhdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyk7IW58fCh0W2VdPW4sdFtzXT1bXSl9cmV0dXJuIHQuZmlsdGVyKGU9PmUubGVuZ3RoKX1wYXJ0c01hdGNoKHQsZSxzPSExKXtsZXQgbj0wLGk9MCxvPVtdLGE9IiI7Zm9yKDtuPHQubGVuZ3RoJiZpPGUubGVuZ3RoOylpZih0W25dPT09ZVtpXSlvLnB1c2goYT09PSJiIj9lW2ldOnRbbl0pLG4rKyxpKys7ZWxzZSBpZihzJiZ0W25dPT09IioqIiYmZVtpXT09PXRbbisxXSlvLnB1c2godFtuXSksbisrO2Vsc2UgaWYocyYmZVtpXT09PSIqKiImJnRbbl09PT1lW2krMV0pby5wdXNoKGVbaV0pLGkrKztlbHNlIGlmKHRbbl09PT0iKiImJmVbaV0mJih0aGlzLm9wdGlvbnMuZG90fHwhZVtpXS5zdGFydHNXaXRoKCIuIikpJiZlW2ldIT09IioqIil7aWYoYT09PSJiIilyZXR1cm4hMTthPSJhIixvLnB1c2godFtuXSksbisrLGkrK31lbHNlIGlmKGVbaV09PT0iKiImJnRbbl0mJih0aGlzLm9wdGlvbnMuZG90fHwhdFtuXS5zdGFydHNXaXRoKCIuIikpJiZ0W25dIT09IioqIil7aWYoYT09PSJhIilyZXR1cm4hMTthPSJiIixvLnB1c2goZVtpXSksbisrLGkrK31lbHNlIHJldHVybiExO3JldHVybiB0Lmxlbmd0aD09PWUubGVuZ3RoJiZvfXBhcnNlTmVnYXRlKCl7aWYodGhpcy5ub25lZ2F0ZSlyZXR1cm47bGV0IHQ9dGhpcy5wYXR0ZXJuLGU9ITEscz0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGgmJnQuY2hhckF0KG4pPT09IiEiO24rKyllPSFlLHMrKztzJiYodGhpcy5wYXR0ZXJuPXQuc2xpY2UocykpLHRoaXMubmVnYXRlPWV9bWF0Y2hPbmUodCxlLHM9ITEpe2xldCBuPXRoaXMub3B0aW9ucztpZih0aGlzLmlzV2luZG93cyl7bGV0IGY9dHlwZW9mIHRbMF09PSJzdHJpbmciJiYvXlthLXpdOiQvaS50ZXN0KHRbMF0pLGc9IWYmJnRbMF09PT0iIiYmdFsxXT09PSIiJiZ0WzJdPT09Ij8iJiYvXlthLXpdOiQvaS50ZXN0KHRbM10pLGI9dHlwZW9mIGVbMF09PSJzdHJpbmciJiYvXlthLXpdOiQvaS50ZXN0KGVbMF0pLEk9IWImJmVbMF09PT0iIiYmZVsxXT09PSIiJiZlWzJdPT09Ij8iJiZ0eXBlb2YgZVszXT09InN0cmluZyImJi9eW2Etel06JC9pLnRlc3QoZVszXSksUz1nPzM6Zj8wOnZvaWQgMCxNPUk/MzpiPzA6dm9pZCAwO2lmKHR5cGVvZiBTPT0ibnVtYmVyIiYmdHlwZW9mIE09PSJudW1iZXIiKXtsZXRbJCxDXT1bdFtTXSxlW01dXTskLnRvTG93ZXJDYXNlKCk9PT1DLnRvTG93ZXJDYXNlKCkmJihlW01dPSQsTT5TP2U9ZS5zbGljZShNKTpTPk0mJih0PXQuc2xpY2UoUykpKX19bGV0e29wdGltaXphdGlvbkxldmVsOmk9MX09dGhpcy5vcHRpb25zO2k+PTImJih0PXRoaXMubGV2ZWxUd29GaWxlT3B0aW1pemUodCkpLHRoaXMuZGVidWcoIm1hdGNoT25lIix0aGlzLHtmaWxlOnQscGF0dGVybjplfSksdGhpcy5kZWJ1ZygibWF0Y2hPbmUiLHQubGVuZ3RoLGUubGVuZ3RoKTtmb3IodmFyIG89MCxhPTAsbD10Lmxlbmd0aCx1PWUubGVuZ3RoO288bCYmYTx1O28rKyxhKyspe3RoaXMuZGVidWcoIm1hdGNoT25lIGxvb3AiKTt2YXIgYz1lW2FdLG09dFtvXTtpZih0aGlzLmRlYnVnKGUsYyxtKSxjPT09ITEpcmV0dXJuITE7aWYoYz09PVcpe3RoaXMuZGVidWcoIkdMT0JTVEFSIixbZSxjLG1dKTt2YXIgcD1vLGQ9YSsxO2lmKGQ9PT11KXtmb3IodGhpcy5kZWJ1ZygiKiogYXQgdGhlIGVuZCIpO288bDtvKyspaWYodFtvXT09PSIuInx8dFtvXT09PSIuLiJ8fCFuLmRvdCYmdFtvXS5jaGFyQXQoMCk9PT0iLiIpcmV0dXJuITE7cmV0dXJuITB9Zm9yKDtwPGw7KXt2YXIgeT10W3BdO2lmKHRoaXMuZGVidWcoYApnbG9ic3RhciB3aGlsZWAsdCxwLGUsZCx5KSx0aGlzLm1hdGNoT25lKHQuc2xpY2UocCksZS5zbGljZShkKSxzKSlyZXR1cm4gdGhpcy5kZWJ1ZygiZ2xvYnN0YXIgZm91bmQgbWF0Y2ghIixwLGwseSksITA7aWYoeT09PSIuInx8eT09PSIuLiJ8fCFuLmRvdCYmeS5jaGFyQXQoMCk9PT0iLiIpe3RoaXMuZGVidWcoImRvdCBkZXRlY3RlZCEiLHQscCxlLGQpO2JyZWFrfXRoaXMuZGVidWcoImdsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUiKSxwKyt9cmV0dXJuISEocyYmKHRoaXMuZGVidWcoYAo+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/YCx0LHAsZSxkKSxwPT09bCkpfWxldCBmO2lmKHR5cGVvZiBjPT0ic3RyaW5nIj8oZj1tPT09Yyx0aGlzLmRlYnVnKCJzdHJpbmcgbWF0Y2giLGMsbSxmKSk6KGY9Yy50ZXN0KG0pLHRoaXMuZGVidWcoInBhdHRlcm4gbWF0Y2giLGMsbSxmKSksIWYpcmV0dXJuITF9aWYobz09PWwmJmE9PT11KXJldHVybiEwO2lmKG89PT1sKXJldHVybiBzO2lmKGE9PT11KXJldHVybiBvPT09bC0xJiZ0W29dPT09IiI7dGhyb3cgbmV3IEVycm9yKCJ3dGY/Iil9YnJhY2VFeHBhbmQoKXtyZXR1cm4gYmUodGhpcy5wYXR0ZXJuLHRoaXMub3B0aW9ucyl9cGFyc2UodCl7aXQodCk7bGV0IGU9dGhpcy5vcHRpb25zO2lmKHQ9PT0iKioiKXJldHVybiBXO2lmKHQ9PT0iIilyZXR1cm4iIjtsZXQgcyxuPW51bGw7KHM9dC5tYXRjaChucykpP249ZS5kb3Q/aXM6cnM6KHM9dC5tYXRjaChxZSkpP249KGUubm9jYXNlP2UuZG90P1plOktlOmUuZG90P0plOlhlKShzWzFdKToocz10Lm1hdGNoKG9zKSk/bj0oZS5ub2Nhc2U/ZS5kb3Q/bHM6YXM6ZS5kb3Q/dXM6aHMpKHMpOihzPXQubWF0Y2goWWUpKT9uPWUuZG90P3RzOlFlOihzPXQubWF0Y2goZXMpKSYmKG49c3MpO2xldCBpPUcuZnJvbUdsb2IodCx0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7cmV0dXJuIG4/T2JqZWN0LmFzc2lnbihpLHt0ZXN0Om59KTppfW1ha2VSZSgpe2lmKHRoaXMucmVnZXhwfHx0aGlzLnJlZ2V4cD09PSExKXJldHVybiB0aGlzLnJlZ2V4cDtsZXQgdD10aGlzLnNldDtpZighdC5sZW5ndGgpcmV0dXJuIHRoaXMucmVnZXhwPSExLHRoaXMucmVnZXhwO2xldCBlPXRoaXMub3B0aW9ucyxzPWUubm9nbG9ic3Rhcj9wczplLmRvdD9kczpncyxuPW5ldyBTZXQoZS5ub2Nhc2U/WyJpIl06W10pLGk9dC5tYXAobD0+e2xldCB1PWwubWFwKGM9PntpZihjIGluc3RhbmNlb2YgUmVnRXhwKWZvcihsZXQgbSBvZiBjLmZsYWdzLnNwbGl0KCIiKSluLmFkZChtKTtyZXR1cm4gdHlwZW9mIGM9PSJzdHJpbmciP3hzKGMpOmM9PT1XP1c6Yy5fc3JjfSk7cmV0dXJuIHUuZm9yRWFjaCgoYyxtKT0+e2xldCBwPXVbbSsxXSxkPXVbbS0xXTtjIT09V3x8ZD09PVd8fChkPT09dm9pZCAwP3AhPT12b2lkIDAmJnAhPT1XP3VbbSsxXT0iKD86XFwvfCIrcysiXFwvKT8iK3A6dVttXT1zOnA9PT12b2lkIDA/dVttLTFdPWQrIig/OlxcL3wiK3MrIik/IjpwIT09VyYmKHVbbS0xXT1kKyIoPzpcXC98XFwvIitzKyJcXC8pIitwLHVbbSsxXT1XKSl9KSx1LmZpbHRlcihjPT5jIT09Vykuam9pbigiLyIpfSkuam9pbigifCIpLFtvLGFdPXQubGVuZ3RoPjE/WyIoPzoiLCIpIl06WyIiLCIiXTtpPSJeIitvK2krYSsiJCIsdGhpcy5uZWdhdGUmJihpPSJeKD8hIitpKyIpLiskIik7dHJ5e3RoaXMucmVnZXhwPW5ldyBSZWdFeHAoaSxbLi4ubl0uam9pbigiIikpfWNhdGNoe3RoaXMucmVnZXhwPSExfXJldHVybiB0aGlzLnJlZ2V4cH1zbGFzaFNwbGl0KHQpe3JldHVybiB0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzP3Quc3BsaXQoIi8iKTp0aGlzLmlzV2luZG93cyYmL15cL1wvW15cL10rLy50ZXN0KHQpP1siIiwuLi50LnNwbGl0KC9cLysvKV06dC5zcGxpdCgvXC8rLyl9bWF0Y2godCxlPXRoaXMucGFydGlhbCl7aWYodGhpcy5kZWJ1ZygibWF0Y2giLHQsdGhpcy5wYXR0ZXJuKSx0aGlzLmNvbW1lbnQpcmV0dXJuITE7aWYodGhpcy5lbXB0eSlyZXR1cm4gdD09PSIiO2lmKHQ9PT0iLyImJmUpcmV0dXJuITA7bGV0IHM9dGhpcy5vcHRpb25zO3RoaXMuaXNXaW5kb3dzJiYodD10LnNwbGl0KCJcXCIpLmpvaW4oIi8iKSk7bGV0IG49dGhpcy5zbGFzaFNwbGl0KHQpO3RoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCJzcGxpdCIsbik7bGV0IGk9dGhpcy5zZXQ7dGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sInNldCIsaSk7bGV0IG89bltuLmxlbmd0aC0xXTtpZighbylmb3IobGV0IGE9bi5sZW5ndGgtMjshbyYmYT49MDthLS0pbz1uW2FdO2ZvcihsZXQgYT0wO2E8aS5sZW5ndGg7YSsrKXtsZXQgbD1pW2FdLHU9bjtpZihzLm1hdGNoQmFzZSYmbC5sZW5ndGg9PT0xJiYodT1bb10pLHRoaXMubWF0Y2hPbmUodSxsLGUpKXJldHVybiBzLmZsaXBOZWdhdGU/ITA6IXRoaXMubmVnYXRlfXJldHVybiBzLmZsaXBOZWdhdGU/ITE6dGhpcy5uZWdhdGV9c3RhdGljIGRlZmF1bHRzKHQpe3JldHVybiBPLmRlZmF1bHRzKHQpLk1pbmltYXRjaH19O08uQVNUPUc7Ty5NaW5pbWF0Y2g9dHQ7Ty5lc2NhcGU9THQ7Ty51bmVzY2FwZT1GO2Z1bmN0aW9uIHllKHIsdCl7cmV0dXJuIE8ocix0KX12YXIgd3Q9Y2xhc3N7Y29uc3RydWN0b3IodCxlLHMsbil7dGhpcy5mZXRjaD10LHRoaXMuYWxsb3dlZEhvc3RzPWUsdGhpcy5sYXN0U3RhdHVzQ29kZT0wLHRoaXMubWVtb3J5T3B0aW9ucz1zLHRoaXMubGFzdEhlYWRlcnM9bj97fTpudWxsfWNvbnRyaWJ1dGUodCl7dFtxXT8/PXt9LHRbcV0uaHR0cF9yZXF1ZXN0PShlLHMsbik9PnRoaXMubWFrZVJlcXVlc3QoZSxzLG4pLHRbcV0uaHR0cF9zdGF0dXNfY29kZT0oKT0+dGhpcy5sYXN0U3RhdHVzQ29kZSx0W3FdLmh0dHBfaGVhZGVycz1lPT50aGlzLmxhc3RIZWFkZXJzPT09bnVsbD8wbjplLnN0b3JlKEpTT04uc3RyaW5naWZ5KHRoaXMubGFzdEhlYWRlcnMpKX1hc3luYyBtYWtlUmVxdWVzdCh0LGUscyl7dGhpcy5sYXN0SGVhZGVycyE9PW51bGwmJih0aGlzLmxhc3RIZWFkZXJzPXt9KSx0aGlzLmxhc3RTdGF0dXNDb2RlPTA7bGV0IG49dC5yZWFkKGUpO2lmKG49PT1udWxsKXJldHVybiAwbjtsZXR7aGVhZGVyczppLGhlYWRlcjpvLHVybDphLG1ldGhvZDpsfT1uLmpzb24oKSx1PWw/PyJHRVQiLGM9bmV3IFVSTChhKTtpZighdGhpcy5hbGxvd2VkSG9zdHMuc29tZShmPT5mPT09Yy5ob3N0bmFtZXx8eWUoYy5ob3N0bmFtZSxmKSkpdGhyb3cgbmV3IEVycm9yKGBDYWxsIGVycm9yOiBIVFRQIHJlcXVlc3QgdG8gIiR7Y30iIGlzIG5vdCBhbGxvd2VkIChubyBhbGxvd2VkSG9zdHMgbWF0Y2ggIiR7Yy5ob3N0bmFtZX0iKWApO2xldCBwPXM9PT0wbnx8dT09PSJHRVQifHx1PT09IkhFQUQiP251bGw6dC5yZWFkKHMpPy5ieXRlcygpLGQ9dGhpcy5mZXRjaCx5PWF3YWl0IGQoYSx7aGVhZGVyczppfHxvLG1ldGhvZDp1LC4uLnA/e2JvZHk6cC5zbGljZSgpfTp7fX0pO3RoaXMubGFzdFN0YXR1c0NvZGU9eS5zdGF0dXMsdGhpcy5sYXN0SGVhZGVycyE9PW51bGwmJih0aGlzLmxhc3RIZWFkZXJzPU9iamVjdC5mcm9tRW50cmllcyh5LmhlYWRlcnMpKTt0cnl7bGV0IGY9dGhpcy5tZW1vcnlPcHRpb25zLm1heEh0dHBSZXNwb25zZUJ5dGVzP2F3YWl0IHZzKHksdGhpcy5tZW1vcnlPcHRpb25zLm1heEh0dHBSZXNwb25zZUJ5dGVzKTpuZXcgVWludDhBcnJheShhd2FpdCB5LmFycmF5QnVmZmVyKCkpO3JldHVybiB0LnN0b3JlKGYpfWNhdGNoKGYpe2lmKGYgaW5zdGFuY2VvZiBFcnJvcil7bGV0IGc9dC5zdG9yZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZi5tZXNzYWdlKSk7cmV0dXJuIHRbel0ubG9nX2Vycm9yKGcpLDBufXJldHVybiAwbn19fTthc3luYyBmdW5jdGlvbiB2cyhyLHQpe2xldCBlPXIuYm9keT8uZ2V0UmVhZGVyKCk7aWYoIWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2xldCBzPTAsbj1bXTtmb3IoO3M8dDspe2xldHtkb25lOmEsdmFsdWU6bH09YXdhaXQgZS5yZWFkKCk7aWYoYSlicmVhaztpZihuLnB1c2gobCkscys9bC5sZW5ndGgscz49dCl0aHJvdyBuZXcgRXJyb3IoYFJlc3BvbnNlIGJvZHkgZXhjZWVkZWQgJHt0fSBieXRlc2ApfWxldCBpPW5ldyBVaW50OEFycmF5KHMpLG89MDtmb3IobGV0IGEgb2YgbilpLnNldChhLG8pLG8rPWEubGVuZ3RoO3JldHVybiBpfXZhciBxPSJleHRpc206aG9zdC9lbnYiLEVzPShhc3luYygpPT57fSkuY29uc3RydWN0b3IsUHQ9V2ViQXNzZW1ibHkuU3VzcGVuZGluZyxSdD1XZWJBc3NlbWJseS5wcm9taXNpbmcsV3Q9Y2xhc3N7I2U7I3Q7I3M9ITE7I247I2w7I3I7Y29uc3RydWN0b3IodCxlLHMsbixpKXt0aGlzLiNlPWUsdGhpcy4jdD1zLHRoaXMuI249bix0aGlzLiNsPXQsdGhpcy4jcj1pfWFzeW5jIHJlc2V0KCl7cmV0dXJuIHRoaXMuaXNBY3RpdmUoKT8hMToodGhpcy4jZVtkdF0oKSwhMCl9aXNBY3RpdmUoKXtyZXR1cm4gdGhpcy4jc31hc3luYyBmdW5jdGlvbkV4aXN0cyh0KXtyZXR1cm4gdHlwZW9mIHRoaXMuI3RbMV0uZXhwb3J0c1t0XT09ImZ1bmN0aW9uIn1hc3luYyBjYWxsQmxvY2sodCxlKXt0aGlzLiNzPSEwO2xldCBzPXRoaXMuI3RbMV0uZXhwb3J0c1t0XTtpZighcyl0aHJvdyBFcnJvcihgUGx1Z2luIGVycm9yOiBmdW5jdGlvbiAiJHt0fSIgZG9lcyBub3QgZXhpc3RgKTtpZih0eXBlb2YgcyE9ImZ1bmN0aW9uIil0aHJvdyBFcnJvcihgUGx1Z2luIGVycm9yOiBleHBvcnQgIiR7dH0iIGlzIG5vdCBhIGZ1bmN0aW9uYCk7dGhpcy4jZVtrdF0oZT8/bnVsbCk7dHJ5e3JldHVybiB0aGlzLiNyP2F3YWl0IFJ0KHMpKCk6cygpLHRoaXMuI2VbY3RdKCl9Y2F0Y2gobil7dGhyb3cgdGhpcy4jZVtjdF0oKSxufWZpbmFsbHl7dGhpcy4jcz0hMX19YXN5bmMgY2FsbCh0LGUscyl7dGhpcy4jZVtkdF0oKTtsZXQgbj10aGlzLiNlW1pdKGUpO3RoaXMuI2VbU3RdKHMpO2xldFtpLG9dPWF3YWl0IHRoaXMuY2FsbEJsb2NrKHQsbiksYT1pIT09bnVsbCxsPWk/P287aWYobD09PW51bGwpcmV0dXJuIG51bGw7bGV0IHU9dGhpcy4jZVtUdF0obCk7aWYoIXUpcmV0dXJuIG51bGw7bGV0IGM9bmV3IGoodS5idWZmZXIpO2lmKGEpdGhyb3cgbmV3IEVycm9yKGBQbHVnaW4tb3JpZ2luYXRlZCBlcnJvcjogJHtjLnN0cmluZygpfWApO3JldHVybiBjfWFzeW5jIGdldEV4cG9ydHMoKXtyZXR1cm4gV2ViQXNzZW1ibHkuTW9kdWxlLmV4cG9ydHModGhpcy4jdFswXSl8fFtdfWFzeW5jIGdldEltcG9ydHMoKXtyZXR1cm4gV2ViQXNzZW1ibHkuTW9kdWxlLmltcG9ydHModGhpcy4jdFswXSl8fFtdfWFzeW5jIGdldEluc3RhbmNlKCl7cmV0dXJuIHRoaXMuI3RbMV19YXN5bmMgY2xvc2UoKXthd2FpdCBQcm9taXNlLmFsbCh0aGlzLiNuLm1hcCh0PT50LmNsb3NlKCkpKSx0aGlzLiNuLmxlbmd0aD0wfX07YXN5bmMgZnVuY3Rpb24gd2Uocix0LGUscz1uZXcgWShBcnJheUJ1ZmZlcixyLmxvZ2dlcixyLmxvZ0xldmVsLHIuY29uZmlnLHIubWVtb3J5KSl7bGV0IG49e1txXTpzW3pdLGVudjp7fX0saT0hMTtmb3IobGV0IG0gaW4gci5mdW5jdGlvbnMpe25bbV09blttXXx8e307Zm9yKGxldFtwLGRdb2YgT2JqZWN0LmVudHJpZXMoci5mdW5jdGlvbnNbbV0pKXtsZXQgeT1kLmNvbnN0cnVjdG9yPT09RXM7aXx8PXk7bGV0IGY9ZC5iaW5kKG51bGwscyk7blttXVtwXT15P25ldyBQdChmKTpmfX1pZihpJiYoIVB0fHwhUnQpKXRocm93IG5ldyBUeXBlRXJyb3IoIlRoaXMgcGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRzIG9uIHRoZSBtYWluIHRocmVhZDsgY29uc2lkZXIgdXNpbmcgYHJ1bkluV29ya2VyYC4iKTtsZXQgbz10LmluZGV4T2YoIm1haW4iKTtpZihvPT09LTEpdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZTogbWFuaWZlc3RzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgIm1haW4iIG1vZHVsZS4gRW5mb3JjZWQgYnkgInNyYy9tYW5pZmVzdC50cyIpJyk7bGV0IGE9bmV3IE1hcCxsPVtdLHU9e3N1c3BlbmRzT25JbnZva2U6aX0sYz1hd2FpdCAkdChzLFsibWFpbiJdLGVbb10sbixyLGwsdCxlLGEsdSk7cmV0dXJuIG5ldyBXdChyLHMsW2Vbb10sY10sbCx1LnN1c3BlbmRzT25JbnZva2UpfWFzeW5jIGZ1bmN0aW9uICR0KHIsdCxlLHMsbixpLG8sYSxsLHUpe2wuc2V0KGUsbnVsbCk7bGV0IGM9e30sbT1XZWJBc3NlbWJseS5Nb2R1bGUuaW1wb3J0cyhlKSxwPW51bGw7Zm9yKGxldHtraW5kOmYsbW9kdWxlOmcsbmFtZTpifW9mIG0pe2xldCBJPW8uaW5kZXhPZihnKTtpZihJPT09LTEpe2lmKGc9PT0id2FzaV9zbmFwc2hvdF9wcmV2aWV3MSImJnA9PT1udWxsKXtpZighaHQuc3VwcG9ydHNXYXNpUHJldmlldzEpdGhyb3cgbmV3IEVycm9yKCJXQVNJIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybSIpO2lmKCFuLndhc2lFbmFibGVkKXRocm93IG5ldyBFcnJvcignV0FTSSBpcyBub3QgZW5hYmxlZDsgc2VlIHRoZSAidXNlV2FzaSIgcGx1Z2luIG9wdGlvbicpO3A9PT1udWxsJiYocD1hd2FpdCBIdChuLmFsbG93ZWRQYXRocyxuLmVuYWJsZVdhc2lPdXRwdXQpLGkucHVzaChwKSxzLndhc2lfc25hcHNob3RfcHJldmlldzE9YXdhaXQgcC5pbXBvcnRPYmplY3QoKSl9aWYoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsZykpdGhyb3cgbmV3IEVycm9yKGBmcm9tIG1vZHVsZSAiJHt0LmpvaW4oJyIvIicpfSI6IGNhbm5vdCByZXNvbHZlIGltcG9ydCAiJHtnfSIgIiR7Yn0iOiBub3QgcHJvdmlkZWQgYnkgaG9zdCBpbXBvcnRzIG5vciBsaW5rZWQgbWFuaWZlc3QgaXRlbXNgKTtpZighT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoc1tnXSxiKSl0aHJvdyBuZXcgRXJyb3IoYGZyb20gbW9kdWxlICIke3Quam9pbignIi8iJyl9IjogY2Fubm90IHJlc29sdmUgaW1wb3J0ICIke2d9IiAiJHtifSIgKCIke2d9IiBpcyBhIGhvc3QgbW9kdWxlLCBidXQgZG9lcyBub3QgY29udGFpbiAiJHtifSIpYCk7aWYoZz09PXEmJmI9PT0iaHR0cF9yZXF1ZXN0IiYmUnQmJnNbZ11bYl09PT1yW3pdLmh0dHBfcmVxdWVzdCl7bGV0IFM9bmV3IHd0KG4uZmV0Y2gsbi5hbGxvd2VkSG9zdHMsbi5tZW1vcnksbi5hbGxvd0h0dHBSZXNwb25zZUhlYWRlcnMpO3Uuc3VzcGVuZHNPbkludm9rZT0hMDtsZXQgTT17fTtTLmNvbnRyaWJ1dGUoTSk7Zm9yKGxldFskLENdb2YgT2JqZWN0LmVudHJpZXMoTVtxXSkpc1tnXVskXT1DLmJpbmQobnVsbCxyKTtzW2ddW2JdPW5ldyBQdChzW2ddW2JdKX1zd2l0Y2goZil7Y2FzZSJmdW5jdGlvbiI6e2NbZ10/Pz17fSxjW2ddW2JdPXNbZ11bYl07YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGZyb20gbW9kdWxlICIke3Quam9pbignIi8iJyl9IjogaW4gaW1wb3J0ICIke2d9IiAiJHtifSIsICIke2Z9Ii10eXBlZCBob3N0IGltcG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0YCl9fWVsc2V7bGV0IFM9YVtJXSxNPVdlYkFzc2VtYmx5Lk1vZHVsZS5leHBvcnRzKFMpO2lmKCFNLmZpbmQoTD0+TC5uYW1lPT09YiYmTC5raW5kPT09ZikpdGhyb3cgbmV3IEVycm9yKGBmcm9tIG1vZHVsZSAiJHt0LmpvaW4oJyIvIicpfSI6IGNhbm5vdCBpbXBvcnQgIiR7Z30iICIke2J9Ijsgbm8gZXhwb3J0IG1hdGNoZWQgcmVxdWVzdGApO2xldCBDPU0uZmluZChMPT5MLm5hbWU9PT0iX3N0YXJ0Iik/YXdhaXQgJHQocixbLi4udCxnXSxTLHMsbixpLG8sYSxuZXcgTWFwLHUpOihsLmhhcyhTKXx8YXdhaXQgJHQocixbLi4udCxnXSxTLHMsbixpLG8sYSxsLHUpLGwuZ2V0KFMpKTtpZihDKWNbZ10/Pz17fSxjW2ddW2JdPUMuZXhwb3J0c1tiXTtlbHNlIGlmKGY9PT0iZnVuY3Rpb24iKXtjW2ddPXt9O2xldCBMPW51bGw7Y1tnXVtiXT0oLi4uc3QpPT57aWYoTClyZXR1cm4gTCguLi5zdCk7bGV0IFI9bC5nZXQoYVtJXSk7aWYoIVIpdGhyb3cgbmV3IEVycm9yKGBmcm9tIG1vZHVsZSBpbnN0YW5jZSAiJHt0LmpvaW4oJyIvIicpfSI6IHRhcmdldCBtb2R1bGUgIiR7Z30iIHdhcyBuZXZlciBpbnN0YW50aWF0ZWRgKTtyZXR1cm4gTD1SLmV4cG9ydHNbYl0sTCguLi5zdCl9fWVsc2UgdGhyb3cgbmV3IEVycm9yKGBmcm9tIG1vZHVsZSAiJHt0LmpvaW4oJyIvIicpfSI6IGNhbm5vdCBpbXBvcnQgIiR7Z30iICIke2J9IjsgY2lyY3VsYXIgaW1wb3J0cyBvZiB0eXBlPSIke2Z9IiBhcmUgbm90IHN1cHBvcnRlZGApfX1sZXQgZD1hd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLGMpLHk9ZC5leHBvcnRzLmhzX2luaXQ/Imhhc2tlbGwiOmQuZXhwb3J0cy5faW5pdGlhbGl6ZT8icmVhY3RvciI6ZC5leHBvcnRzLl9zdGFydD8iY29tbWFuZCI6Im5vbmUiO2lmKHApYXdhaXQgcD8uaW5pdGlhbGl6ZShkKSxkLmV4cG9ydHMuaHNfaW5pdCYmZC5leHBvcnRzLmhzX2luaXQoKTtlbHNlIHN3aXRjaCh5KXtjYXNlImNvbW1hbmQiOmQuZXhwb3J0cy5faW5pdGlhbGl6ZSYmZC5leHBvcnRzLl9pbml0aWFsaXplKCksZC5leHBvcnRzLl9zdGFydCgpO2JyZWFrO2Nhc2UicmVhY3RvciI6ZC5leHBvcnRzLl9pbml0aWFsaXplKCk7YnJlYWs7Y2FzZSJoYXNrZWxsIjpkLmV4cG9ydHMuaHNfaW5pdCgpO2JyZWFrfXJldHVybiBsLnNldChlLGQpLGR9dmFyIE50PWNsYXNze2NvbnN0cnVjdG9yKHQpe2lmKCF0KXRocm93IG5ldyBFcnJvcigiVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGU6IHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGJlIGludm9rZWQgYXMgYSB3ZWIgd29ya2VyLiIpO3RoaXMuc2hhcmVkRGF0YT1udWxsLHRoaXMuc2hhcmVkRGF0YVZpZXc9bnVsbCx0aGlzLmhvc3RGbGFnPW51bGwsdGhpcy5wb3J0PXQsdGhpcy5wb3J0Lm9uKCJtZXNzYWdlIixlPT50aGlzLmhhbmRsZU1lc3NhZ2UoZSkpLHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToiaW5pdGlhbGl6ZWQifSksdGhpcy5keW5hbWljSGFuZGxlcnM9bmV3IE1hcCx0aGlzLmR5bmFtaWNIYW5kbGVycy5zZXQoImNhbGwiLGFzeW5jKGUscyxuLGkpPT57aWYoIXRoaXMuY29udGV4dCl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgc3RhdGU6IG5vIGNvbnRleHQgYXZhaWxhYmxlIHRvIHdvcmtlciByZWFjdG9yIik7dGhpcy5jb250ZXh0W2Z0XShpKTtsZXQgbz1hd2FpdCB0aGlzLnBsdWdpbj8uY2FsbEJsb2NrKHMsbikudGhlbihhPT5bbnVsbCxhXSxhPT5bYSxudWxsXSk7aT10aGlzLmNvbnRleHRbcHRdKCk7Zm9yKGxldFthXW9mIGkuYmxvY2tzKWEmJmUucHVzaChhKTtyZXR1cm4gb1swXSYmKG9bMF09e29yaWdpbmFsU3RhY2s6b1swXT8uc3RhY2ssbWVzc2FnZTpvWzBdPy5tZXNzYWdlfSkse3Jlc3VsdHM6byxzdGF0ZTppfX0pLHRoaXMuZHluYW1pY0hhbmRsZXJzLnNldCgicmVzZXQiLGFzeW5jIGU9PnRoaXMucGx1Z2luPy5yZXNldCgpKSx0aGlzLmR5bmFtaWNIYW5kbGVycy5zZXQoImdldEV4cG9ydHMiLGFzeW5jIGU9PnRoaXMucGx1Z2luPy5nZXRFeHBvcnRzKCkpLHRoaXMuZHluYW1pY0hhbmRsZXJzLnNldCgiZ2V0SW1wb3J0cyIsYXN5bmMgZT0+dGhpcy5wbHVnaW4/LmdldEltcG9ydHMoKSksdGhpcy5keW5hbWljSGFuZGxlcnMuc2V0KCJmdW5jdGlvbkV4aXN0cyIsYXN5bmMoZSxzKT0+dGhpcy5wbHVnaW4/LmZ1bmN0aW9uRXhpc3RzKHMpKX1hc3luYyBoYW5kbGVNZXNzYWdlKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2UiaW5pdCI6cmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlSW5pdCh0KTtjYXNlImludm9rZSI6cmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlSW52b2tlKHQpfX1hc3luYyBoYW5kbGVJbnZva2UodCl7bGV0IGU9dGhpcy5keW5hbWljSGFuZGxlcnMuZ2V0KHQuaGFuZGxlcik7aWYoIWUpcmV0dXJuIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToicmV0dXJuIixyZXN1bHQ6W2BubyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yICR7dC5oYW5kbGVyfWAsbnVsbF19KTtsZXQgcz1bXSxuPWF3YWl0IGUocywuLi50LmFyZ3N8fFtdKS50aGVuKGk9PltudWxsLGldLGk9PltpLG51bGxdKTtyZXR1cm4gblswXSYmKG5bMF09e29yaWdpbmFsU3RhY2s6blswXT8uc3RhY2ssbWVzc2FnZTpuWzBdPy5tZXNzYWdlfSksdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHt0eXBlOiJyZXR1cm4iLHJlc3VsdHM6bn0scyl9YXN5bmMgaGFuZGxlSW5pdCh0KXt0aGlzLnNoYXJlZERhdGE9dC5zaGFyZWREYXRhLHRoaXMuc2hhcmVkRGF0YVZpZXc9bmV3IERhdGFWaWV3KHQuc2hhcmVkRGF0YSksdGhpcy5ob3N0RmxhZz1uZXcgSW50MzJBcnJheSh0aGlzLnNoYXJlZERhdGEpO2xldCBlPU9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0LmZ1bmN0aW9ucykubWFwKChbdSxjXSk9Plt1LE9iamVjdC5mcm9tRW50cmllcyhjLm1hcChtPT5bbSwocCwuLi5kKT0+dGhpcy5jYWxsSG9zdChwLHUsbSxkKV0pKV0pKSx7dHlwZTpzLG1vZHVsZXM6bixmdW5jdGlvbnM6aSwuLi5vfT10LGE9dT0+Yz0+dGhpcy5wb3J0LnBvc3RNZXNzYWdlKHt0eXBlOiJsb2ciLGxldmVsOnUsbWVzc2FnZTpjfSksbD1PYmplY3QuZnJvbUVudHJpZXMoWyJpbmZvIiwiZGVidWciLCJ3YXJuIiwiZXJyb3IiLCJ0cmFjZSJdLm1hcCh1PT5bdSxhKHUpXSkpO3RoaXMuY29udGV4dD1uZXcgWShBcnJheUJ1ZmZlcixsLHQubG9nTGV2ZWwsdC5jb25maWcsdC5tZW1vcnkpLHRoaXMucGx1Z2luPWF3YWl0IHdlKHsuLi5vLGZ1bmN0aW9uczplLGZldGNoLGxvZ2dlcjpsfSx0Lm5hbWVzLG4sdGhpcy5jb250ZXh0KSx0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe3R5cGU6InJlYWR5In0pfWNhbGxIb3N0KHQsZSxzLG4pe2lmKCF0aGlzLmhvc3RGbGFnKXRocm93IG5ldyBFcnJvcigiYXR0ZW1wdGVkIHRvIGNhbGwgaG9zdCBiZWZvcmUgcmVjZWl2aW5nIHNoYXJlZCBhcnJheSBidWZmZXIiKTtBdG9taWNzLnN0b3JlKHRoaXMuaG9zdEZsYWcsMCxOKTtsZXQgaT10W3B0XSgpO3RoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToiaW52b2tlIixuYW1lc3BhY2U6ZSxmdW5jOnMsYXJnczpuLHN0YXRlOml9KTtsZXQgbz1uZXcgeHQodGhpcy5zaGFyZWREYXRhKSxhPVtdLGw7ZG97bGV0IHU9by5yZWFkVWludDgoKTtzd2l0Y2godSl7Y2FzZSAyNTU6cmV0dXJuIGkuYmxvY2tzPWEsdFtmdF0oaSksby5jbG9zZSgpLGw7Y2FzZSAxOmw9by5yZWFkVWludDY0KCk7YnJlYWs7Y2FzZSAyOmw9by5yZWFkRmxvYXQ2NCgpO2JyZWFrO2Nhc2UgMzpsPXZvaWQgMDticmVhaztjYXNlIDQ6e2xldCBjPW8ucmVhZFVpbnQzMigpLG09by5yZWFkVWludDMyKCk7aWYoIW0pYS5wdXNoKFtudWxsLGNdKTtlbHNle2xldCBwPW5ldyBVaW50OEFycmF5KG0pO28ucmVhZChwKSxhLnB1c2goW3AuYnVmZmVyLGNdKX19YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VjdGlvbiB0eXBlPSIke3V9IiBhdCBwb3NpdGlvbiAke28ucG9zaXRpb259OyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSAoaHR0cHM6Ly9naXRodWIuY29tL2V4dGlzbS9qcy1zZGsvaXNzdWVzL25ldz90aXRsZT1zaGFyZWQrYXJyYXkrYnVmZmVyK2JhZCtzZWN0aW9uK3R5cGUrJHt1fSZsYWJlbHM9YnVnKWApfX13aGlsZSgxKX19O25ldyBOdChBcyk7dmFyIGtzPTUwMCxldCx4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtFKHRoaXMsZXQsdm9pZCAwKTt0aGlzLmlucHV0PXQsdGhpcy5pbnB1dE9mZnNldD1OLHRoaXMuZmxhZz1uZXcgSW50MzJBcnJheSh0aGlzLmlucHV0KSx0aGlzLnNjcmF0Y2g9bmV3IEFycmF5QnVmZmVyKDgpLHRoaXMuc2NyYXRjaFZpZXc9bmV3IERhdGFWaWV3KHRoaXMuc2NyYXRjaCksdGhpcy5wb3NpdGlvbj0wLHgodGhpcyxldCwwKSx0aGlzLndhaXQoKX1jbG9zZSgpe3RoaXMuc2lnbmFsKCksQXRvbWljcy5zdG9yZSh0aGlzLmZsYWcsMCxOKX13YWl0KCl7bGV0IHQ9TjtkbyB0PUF0b21pY3MubG9hZCh0aGlzLmZsYWcsMCksdD09PU4mJkF0b21pY3Mud2FpdCh0aGlzLmZsYWcsMCxOLGtzKTt3aGlsZSh0PD1OKTt4KHRoaXMsZXQsQXRvbWljcy5sb2FkKHRoaXMuZmxhZywwKSksdGhpcy5pbnB1dE9mZnNldD1OfWdldCBhdmFpbGFibGUoKXtyZXR1cm4gaCh0aGlzLGV0KS10aGlzLmlucHV0T2Zmc2V0fXNpZ25hbCgpe0F0b21pY3Muc3RvcmUodGhpcy5mbGFnLDAsTiksQXRvbWljcy5ub3RpZnkodGhpcy5mbGFnLDAsMSl9cHVsbCgpe3RoaXMuc2lnbmFsKCksdGhpcy53YWl0KCl9cmVhZCh0KXtpZih0aGlzLnBvc2l0aW9uKz10LmJ5dGVMZW5ndGgsdC5ieXRlTGVuZ3RoPHRoaXMuYXZhaWxhYmxlKXt0LnNldChuZXcgVWludDhBcnJheSh0aGlzLmlucHV0KS5zdWJhcnJheSh0aGlzLmlucHV0T2Zmc2V0LHRoaXMuaW5wdXRPZmZzZXQrdC5ieXRlTGVuZ3RoKSksdGhpcy5pbnB1dE9mZnNldCs9dC5ieXRlTGVuZ3RoO3JldHVybn1sZXQgZT0wLHM9dGhpcy5hdmFpbGFibGU7ZG97aWYodC5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5pbnB1dCkuc3ViYXJyYXkodGhpcy5pbnB1dE9mZnNldCx0aGlzLmlucHV0T2Zmc2V0K3MpLGUpLGUrPXMsdGhpcy5pbnB1dE9mZnNldCs9cyxlPT09dC5ieXRlTGVuZ3RofHx0aGlzLmF2YWlsYWJsZTwwKWJyZWFrO3RoaXMucHVsbCgpLHM9TWF0aC5taW4oTWF0aC5tYXgodGhpcy5hdmFpbGFibGUsMCksdC5ieXRlTGVuZ3RoLWUpfXdoaWxlKGUhPT10LmJ5dGVMZW5ndGgpfXJlYWRVaW50OCgpe3JldHVybiB0aGlzLnJlYWQobmV3IFVpbnQ4QXJyYXkodGhpcy5zY3JhdGNoKS5zdWJhcnJheSgwLDEpKSx0aGlzLnNjcmF0Y2hWaWV3LmdldFVpbnQ4KDApfXJlYWRVaW50MzIoKXtyZXR1cm4gdGhpcy5yZWFkKG5ldyBVaW50OEFycmF5KHRoaXMuc2NyYXRjaCkuc3ViYXJyYXkoMCw0KSksdGhpcy5zY3JhdGNoVmlldy5nZXRVaW50MzIoMCwhMCl9cmVhZFVpbnQ2NCgpe3JldHVybiB0aGlzLnJlYWQobmV3IFVpbnQ4QXJyYXkodGhpcy5zY3JhdGNoKSksdGhpcy5zY3JhdGNoVmlldy5nZXRCaWdVaW50NjQoMCwhMCl9cmVhZEZsb2F0NjQoKXtyZXR1cm4gdGhpcy5yZWFkKG5ldyBVaW50OEFycmF5KHRoaXMuc2NyYXRjaCkpLHRoaXMuc2NyYXRjaFZpZXcuZ2V0RmxvYXQ2NCgwLCEwKX19O2V0PW5ldyBXZWFrTWFwLHh0LlNBQl9JRFg9MDsK\");\n", "/*eslint-disable no-empty*/\nimport {\n  CallContext,\n  ENV,\n  EXPORT_STATE,\n  GET_BLOCK,\n  IMPORT_STATE,\n  RESET,\n  SET_HOST_CONTEXT,\n  STORE,\n} from './call-context.ts';\nimport { type InternalConfig, PluginOutput, SAB_BASE_OFFSET, SharedArrayBufferSection } from './interfaces.ts';\nimport { WORKER_URL } from './worker-url.ts';\nimport { Worker } from 'node:worker_threads';\nimport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\nimport { EXTISM_ENV } from './foreground-plugin.ts';\nimport { HttpContext } from './http-context.ts';\n\n// Firefox has not yet implemented Atomics.waitAsync, but we can polyfill\n// it using a worker as a one-off.\n//\n// TODO: we should probably give _each_ background plugin its own waiter\n// script.\nconst AtomicsWaitAsync =\n  Atomics.waitAsync ||\n  (() => {\n    const src = `onmessage = ev => {\n    const [b, i, v] = ev.data\n    const f = new Int32Array(b)\n    postMessage(Atomics.wait(f, i, v));\n  }`;\n\n    const blob = new (Blob as any)([src], { type: 'text/javascript' });\n    const url = URL.createObjectURL(blob);\n    const w = new Worker(url, { execArgv: [] });\n    return (ia: any, index, value) => {\n      const promise = new Promise((resolve) => {\n        w.once('message', (data) => {\n          resolve(data);\n        });\n      });\n      w.postMessage([ia.buffer, index, value]);\n      return { async: true, value: promise };\n    };\n  })();\n\nclass BackgroundPlugin {\n  sharedData: SharedArrayBuffer;\n  sharedDataView: DataView;\n  hostFlag: Int32Array;\n  opts: InternalConfig;\n  worker: Worker;\n  modules: WebAssembly.Module[];\n  names: string[];\n\n  #context: CallContext;\n  #request: [(result: any) => void, (result: any) => void] | null = null;\n\n  constructor(\n    worker: Worker,\n    sharedData: SharedArrayBuffer,\n    names: string[],\n    modules: WebAssembly.Module[],\n    opts: InternalConfig,\n    context: CallContext,\n  ) {\n    this.sharedData = sharedData;\n    this.sharedDataView = new DataView(sharedData);\n    this.hostFlag = new Int32Array(sharedData);\n    this.opts = opts;\n    this.names = names;\n    this.modules = modules;\n    this.worker = worker;\n    this.#context = context;\n    this.hostFlag[0] = SAB_BASE_OFFSET;\n\n    this.worker.on('message', (ev) => this.#handleMessage(ev));\n  }\n\n  async #handleTimeout() {\n    // block new requests from coming in & the current request from settling\n    const request = this.#request;\n    this.#request = [() => {}, () => {}];\n\n    const timedOut = {};\n    const failed = {};\n    const result = await Promise.race(\n      [\n        timeout(this.opts.timeoutMs, timedOut),\n        Promise.all([terminateWorker(this.worker), createWorker(this.opts, this.names, this.modules, this.sharedData)]),\n      ].filter(Boolean),\n    ).catch(() => failed);\n    this.#context[RESET]();\n\n    // Oof. The Wasm module failed to even _restart_ in the time allotted. There's\n    // not much we can do at this point. Release as much memory as we can while\n    // squatting on `this.#request` so the plugin always looks \"active\".\n    if (result === timedOut) {\n      this.opts.logger.error(\n        'EXTISM: Plugin timed out while handling a timeout. Plugin will hang. This Wasm module may have a non-trivial `start` section.',\n      );\n      this.worker = null as unknown as any;\n      // TODO: expose some way to observe that the plugin is in a \"poisoned\" state.\n      return;\n    }\n\n    // The worker failed to start up for some other reason. This is pretty unlikely to happen!\n    if (result === failed) {\n      this.opts.logger.error('EXTISM: Plugin failed to restart during a timeout. Plugin will hang.');\n      this.worker = null as unknown as any;\n      return;\n    }\n    const [, worker] = result as any[];\n    this.worker = worker as Worker;\n\n    if (request) {\n      request.pop()!(new Error('EXTISM: call canceled due to timeout'));\n    }\n    this.#request = null;\n\n    this.worker.on('message', (ev) => this.#handleMessage(ev));\n  }\n\n  async reset(): Promise<boolean> {\n    if (this.isActive()) {\n      return false;\n    }\n\n    await this.#invoke('reset');\n\n    this.#context[RESET]();\n    return true;\n  }\n\n  isActive() {\n    return Boolean(this.#request);\n  }\n\n  async #handleMessage(ev: any) {\n    switch (ev?.type) {\n      case 'invoke':\n        return this.#handleInvoke(ev);\n      case 'return':\n        return this.#handleReturn(ev);\n      case 'log':\n        return this.#handleLog(ev);\n    }\n  }\n\n  #handleLog(ev: any) {\n    const fn = (this.opts.logger as any)[ev.level as string];\n    if (typeof fn !== 'function') {\n      this.opts.logger?.error(`failed to find loglevel=\"${ev.level}\" on logger: message=${ev.message}`);\n    } else {\n      fn.call(this.opts.logger, ev.message);\n    }\n  }\n\n  #handleReturn(ev: any) {\n    const responder = this.#request || null;\n    if (responder === null) {\n      // This is fatal, we should probably panic\n      throw new Error(`received \"return\" call with no corresponding request`);\n    }\n\n    this.#request = null;\n\n    const [resolve, reject] = responder;\n\n    if (!Array.isArray(ev.results) || ev.results.length !== 2) {\n      return reject(new Error(`received malformed \"return\"`) as any);\n    }\n\n    const [err, data] = ev.results;\n\n    err ? reject(err) : resolve(data);\n  }\n\n  // host -> guest() invoke\n  async #invoke(handler: string, ...args: any[]): Promise<any> {\n    if (this.#request) {\n      throw new Error('plugin is not reentrant');\n    }\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    this.#request = [resolve as any, reject as any];\n\n    if (!this.worker) {\n      throw new Error('worker not initialized');\n    }\n\n    const timedOut = {};\n\n    // Since this creates a new promise, we need to provide\n    // an empty error handler.\n    Promise.race([timeout(this.opts.timeoutMs, timedOut), promise].filter(Boolean)).then(\n      async (v) => {\n        if (v === timedOut) {\n          await this.#handleTimeout();\n        }\n      },\n      () => {},\n    );\n\n    this.worker.postMessage({\n      type: 'invoke',\n      handler,\n      args,\n    });\n\n    return promise;\n  }\n\n  async functionExists(funcName: string): Promise<boolean> {\n    return await this.#invoke('functionExists', funcName);\n  }\n\n  // host -> guest invoke()\n  async call<T = any>(funcName: string, input?: string | Uint8Array, hostContext?: T): Promise<PluginOutput | null> {\n    const index = this.#context[STORE](input);\n    this.#context[SET_HOST_CONTEXT](hostContext);\n\n    const [errorIdx, outputIdx] = await this.callBlock(funcName, index);\n\n    const shouldThrow = errorIdx !== null;\n    const idx = errorIdx ?? outputIdx;\n\n    if (idx === null) {\n      return null;\n    }\n\n    const block = this.#context[GET_BLOCK](idx);\n\n    if (block === null) {\n      return null;\n    }\n\n    const buf = new PluginOutput(\n      CAPABILITIES.allowSharedBufferCodec ? block.buffer : new Uint8Array(block.buffer).slice().buffer,\n    );\n\n    if (shouldThrow) {\n      const msg = new TextDecoder().decode(buf);\n      throw new Error(`Plugin-originated error: ${msg}`);\n    }\n\n    return buf;\n  }\n\n  async callBlock(funcName: string, input: number | null): Promise<[number | null, number | null]> {\n    const exported = this.#context[EXPORT_STATE]();\n    const { results, state } = await this.#invoke('call', funcName, input, exported);\n    this.#context[IMPORT_STATE](state, true);\n\n    const [err, data] = results;\n    if (err) {\n      throw err;\n    }\n\n    return data;\n  }\n\n  async getExports(): Promise<WebAssembly.ModuleExportDescriptor[]> {\n    return await this.#invoke('getExports');\n  }\n\n  async getImports(): Promise<WebAssembly.ModuleImportDescriptor[]> {\n    return await this.#invoke('getImports');\n  }\n\n  async getInstance(): Promise<WebAssembly.Instance> {\n    throw new Error('todo');\n  }\n\n  async close(): Promise<void> {\n    if (this.worker) {\n      await terminateWorker(this.worker);\n      this.worker = null as any;\n    }\n  }\n\n  // guest -> host invoke()\n  async #handleInvoke(ev: any) {\n    const writer = new RingBufferWriter(this.sharedData);\n    const namespace = this.opts.functions[ev.namespace];\n    const func = (namespace ?? {})[ev.func];\n    // XXX(chrisdickinson): this is c\u00FCrs\u00EBd code. Add a setTimeout because some platforms\n    // don't spin their event loops if the only pending item is a Promise generated by Atomics.waitAsync.\n    //\n    // - https://github.com/nodejs/node/pull/44409\n    // - https://github.com/denoland/deno/issues/14786\n    const timer = setInterval(() => {}, 0);\n    try {\n      if (!func) {\n        throw Error(`Plugin error: host function \"${ev.namespace}\" \"${ev.func}\" does not exist`);\n      }\n\n      // Fill the shared array buffer with an expected garbage value to make debugging\n      // errors more straightforward\n      new Uint8Array(this.sharedData).subarray(8).fill(0xfe);\n\n      this.#context[IMPORT_STATE](ev.state, true);\n\n      const data = await func(this.#context, ...ev.args);\n\n      const { blocks } = this.#context[EXPORT_STATE]();\n\n      // Writes to the ring buffer MAY return a promise if the write would wrap.\n      // Writes that fit within the ring buffer return void.\n      let promise: any;\n      for (const [buffer, destination] of blocks) {\n        promise = writer.writeUint8(SharedArrayBufferSection.Block);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint32(destination);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint32(buffer?.byteLength || 0);\n        if (promise) {\n          await promise;\n        }\n\n        if (buffer) {\n          promise = writer.write(buffer);\n          if (promise) {\n            await promise;\n          }\n        }\n      }\n\n      if (typeof data === 'bigint') {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetI64);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint64(data);\n        if (promise) {\n          await promise;\n        }\n      } else if (typeof data === 'number') {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetF64);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeFloat64(data);\n        if (promise) {\n          await promise;\n        }\n      } else {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetVoid);\n        if (promise) {\n          await promise;\n        }\n      }\n\n      promise = writer.writeUint8(SharedArrayBufferSection.End);\n      if (promise) {\n        await promise;\n      }\n      await writer.flush();\n    } catch (err) {\n      this.close();\n      const [, reject] = this.#request as any[];\n      this.#request = null;\n      return reject(err);\n    } finally {\n      clearInterval(timer);\n    }\n  }\n}\n\n// Return control to the waiting promise. Anecdotally, this appears to help\n// with a race condition in Bun.\nconst MAX_WAIT = 500;\nclass RingBufferWriter {\n  output: SharedArrayBuffer;\n  scratch: ArrayBuffer;\n  scratchView: DataView;\n  outputOffset: number;\n  flag: Int32Array;\n\n  static SAB_IDX = 0;\n\n  constructor(output: SharedArrayBuffer) {\n    this.scratch = new ArrayBuffer(8);\n    this.scratchView = new DataView(this.scratch);\n    this.output = output;\n    this.outputOffset = SAB_BASE_OFFSET;\n    this.flag = new Int32Array(this.output);\n    this.wait(0);\n  }\n\n  async wait(lastKnownValue: number) {\n    // if the flag == SAB_BASE_OFFSET, that means \"we have ownership\", every other value means \"the thread has ownership\"\n    let value = 0;\n    do {\n      value = Atomics.load(this.flag, 0);\n      if (value === lastKnownValue) {\n        const { value: result, async } = AtomicsWaitAsync(this.flag, 0, lastKnownValue, MAX_WAIT);\n        if (async) {\n          if ((await result) === 'timed-out') {\n            continue;\n          }\n        }\n      }\n    } while (value === lastKnownValue);\n  }\n\n  signal() {\n    const old = Atomics.load(this.flag, 0);\n    while (Atomics.compareExchange(this.flag, 0, old, this.outputOffset) === old) {}\n    Atomics.notify(this.flag, 0, 1);\n  }\n\n  async flush() {\n    if (this.outputOffset === SAB_BASE_OFFSET) {\n      // no need to flush -- we haven't written anything!\n      return;\n    }\n\n    const workerId = this.outputOffset;\n    this.signal();\n    this.outputOffset = SAB_BASE_OFFSET;\n    await this.wait(workerId);\n  }\n\n  async spanningWrite(input: Uint8Array) {\n    let inputOffset = 0;\n    let toWrite = this.output.byteLength - this.outputOffset;\n    let flushedWriteCount = 1 + Math.floor((input.byteLength - toWrite) / (this.output.byteLength - SAB_BASE_OFFSET));\n    const finalWrite = (input.byteLength - toWrite) % (this.output.byteLength - SAB_BASE_OFFSET);\n\n    do {\n      new Uint8Array(this.output).set(input.subarray(inputOffset, inputOffset + toWrite), this.outputOffset);\n\n      // increment the offset so we know we've written _something_ (and can bypass the \"did we not write anything\" check in `flush()`)\n      this.outputOffset += toWrite;\n      inputOffset += toWrite;\n      await this.flush();\n\n      // reset toWrite to the maximum available length. (So we may write 29 bytes the first time, but 4096 the next N times.\n      toWrite = this.output.byteLength - SAB_BASE_OFFSET;\n      --flushedWriteCount;\n    } while (flushedWriteCount != 0);\n\n    if (finalWrite) {\n      this.write(input.subarray(inputOffset, inputOffset + finalWrite));\n    }\n  }\n\n  write(bytes: ArrayBufferLike): void | Promise<void> {\n    if (bytes.byteLength + this.outputOffset < this.output.byteLength) {\n      new Uint8Array(this.output).set(new Uint8Array(bytes), this.outputOffset);\n      this.outputOffset += bytes.byteLength;\n      return;\n    }\n\n    return this.spanningWrite(new Uint8Array(bytes));\n  }\n\n  writeUint8(value: number): void | Promise<void> {\n    this.scratchView.setUint8(0, value);\n    return this.write(this.scratch.slice(0, 1));\n  }\n\n  writeUint32(value: number): void | Promise<void> {\n    this.scratchView.setUint32(0, value, true);\n    return this.write(this.scratch.slice(0, 4));\n  }\n\n  writeUint64(value: bigint): void | Promise<void> {\n    this.scratchView.setBigUint64(0, value, true);\n    return this.write(this.scratch.slice(0, 8));\n  }\n\n  writeFloat64(value: number): void | Promise<void> {\n    this.scratchView.setFloat64(0, value, true);\n    return this.write(this.scratch.slice(0, 8));\n  }\n}\n\nexport async function createBackgroundPlugin(\n  opts: InternalConfig,\n  names: string[],\n  modules: WebAssembly.Module[],\n): Promise<BackgroundPlugin> {\n  const context = new CallContext(SharedArrayBuffer, opts.logger, opts.logLevel, opts.config, opts.memory);\n  const httpContext = new HttpContext(opts.fetch, opts.allowedHosts, opts.memory, opts.allowHttpResponseHeaders);\n  httpContext.contribute(opts.functions);\n\n  // NB(chrisdickinson): In order for the host and guest to have the same \"view\" of the\n  // variables, forward the guest's var_get/var_set methods up to the host CallContext.\n  // If they're overridden, however, preserve the user-provided values.\n  opts.functions[EXTISM_ENV] ??= {};\n  opts.functions[EXTISM_ENV].var_get ??= (_: CallContext, key: bigint) => {\n    return context[ENV].var_get(key);\n  };\n  opts.functions[EXTISM_ENV].var_set ??= (_: CallContext, key: bigint, val: bigint) => {\n    return context[ENV].var_set(key, val);\n  };\n\n  // NB(chrisdickinson): We *have* to create the SharedArrayBuffer in\n  // the parent context because -- for whatever reason! -- chromium does\n  // not allow the creation of shared buffers in worker contexts, but firefox\n  // and webkit do.\n  const sharedData = new (SharedArrayBuffer as any)(opts.sharedArrayBufferSize);\n  new Uint8Array(sharedData).subarray(8).fill(0xfe);\n\n  const timedOut = {};\n\n  // If we fail to initialize the worker (because Wasm hangs), we need access to\n  // the partially-initialized worker so that we can terminate its thread.\n  let earlyWorker: Worker;\n  const onworker = (w: Worker) => {\n    earlyWorker = w;\n  };\n\n  const worker = await Promise.race(\n    [timeout(opts.timeoutMs, timedOut), createWorker(opts, names, modules, sharedData, onworker)].filter(Boolean),\n  );\n\n  if (worker === timedOut) {\n    await terminateWorker(earlyWorker!);\n    throw new Error('EXTISM: timed out while waiting for plugin to instantiate');\n  }\n  return new BackgroundPlugin(worker as Worker, sharedData, names, modules, opts, context);\n}\n\nasync function createWorker(\n  opts: InternalConfig,\n  names: string[],\n  modules: WebAssembly.Module[],\n  sharedData: SharedArrayBuffer,\n  onworker: (_w: Worker) => void = (_w: Worker) => {},\n): Promise<Worker> {\n  const worker = new Worker(WORKER_URL, opts.nodeWorkerArgs);\n  onworker(worker);\n\n  await new Promise((resolve, reject) => {\n    worker.on('message', function handler(ev) {\n      if (ev?.type !== 'initialized') {\n        reject(new Error(`received unexpected message (type=${ev?.type})`));\n      }\n\n      worker.removeListener('message', handler);\n      resolve(null);\n    });\n  });\n\n  const onready = new Promise((resolve, reject) => {\n    worker.on('message', function handler(ev) {\n      if (ev?.type !== 'ready') {\n        reject(new Error(`received unexpected message (type=${ev?.type})`));\n      }\n\n      worker.removeListener('message', handler);\n      resolve(null);\n    });\n  });\n\n  const { fetch: _, logger: __, ...rest } = opts;\n  const message = {\n    ...rest,\n    type: 'init',\n    functions: Object.fromEntries(Object.entries(opts.functions || {}).map(([k, v]) => [k, Object.keys(v)])),\n    names,\n    modules,\n    sharedData,\n  };\n\n  worker.postMessage(message);\n  await onready;\n\n  return worker;\n}\n\nfunction timeout(ms: number | null, sentinel: any) {\n  return ms === null ? null : new Promise((resolve) => setTimeout(() => resolve(sentinel), ms));\n}\n\nasync function terminateWorker(w: Worker) {\n  if (typeof (globalThis as any).Bun !== 'undefined') {\n    const timer = setTimeout(() => {}, 10);\n    await w.terminate();\n    clearTimeout(timer);\n  } else {\n    await w.terminate();\n  }\n}\n", "import { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nimport {\n  logLevelToPriority,\n  type ExtismPluginOptions,\n  type InternalConfig,\n  type ManifestLike,\n  type Plugin,\n} from './interfaces.ts';\n\nimport { toWasmModuleData as _toWasmModuleData } from './manifest.ts';\n\nimport { createForegroundPlugin as _createForegroundPlugin } from './foreground-plugin.ts';\nimport { createBackgroundPlugin as _createBackgroundPlugin } from './background-plugin.ts';\n\nexport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nexport type {\n  Capabilities,\n  ExtismPluginOptions,\n  LogLevel,\n  Manifest,\n  ManifestLike,\n  ManifestWasm,\n  ManifestWasmData,\n  ManifestWasmModule,\n  ManifestWasmPath,\n  ManifestWasmResponse,\n  ManifestWasmUrl,\n  MemoryOptions,\n  Plugin,\n  PluginConfig,\n  PluginConfigLike,\n  PluginOutput,\n} from './interfaces.ts';\n\nexport type { CallContext, CallContext as CurrentPlugin } from './call-context.ts';\n\n/**\n * Create a {@link Plugin} given a {@link ManifestLike} and {@link ExtismPluginOptions}.\n *\n * Plugins wrap Wasm modules, exposing rich access to exported functions.\n *\n * ```ts\n * const plugin = await createPlugin(\n *   'https://github.com/extism/plugins/releases/download/v0.3.0/count_vowels.wasm',\n *   { useWasi: true }\n * );\n *\n * try {\n *   const result = await plugin.call('count_vowels', 'hello world');\n *   const parsed = result.json();\n *\n *   console.log(parsed); // { count: 3, total: 3, vowels: \"aeiouAEIOU\" }\n * } finally {\n *   await plugin.close();\n * }\n * ```\n *\n * {@link Plugin | `Plugin`} can run on a background thread when the\n * environment supports it. You can see if the current environment supports\n * background plugins by checking the {@link Capabilities#hasWorkerCapability |\n * `hasWorkerCapability`} property of {@link CAPABILITIES}.\n *\n * @param manifest A {@link ManifestLike | `ManifestLike`}. May be a `string`\n * representing a URL, JSON, a path to a wasm file ({@link\n * Capabilities#manifestSupportsPaths | in environments} where paths are\n * supported); an [ArrayBuffer](https://mdn.io/ArrayBuffer); or a {@link\n * Manifest}.\n *\n * @param opts {@link ExtismPluginOptions | options} for controlling the behavior\n * of the plugin.\n *\n * @returns a promise for a {@link Plugin}.\n */\nexport async function createPlugin(\n  manifest: ManifestLike | PromiseLike<ManifestLike>,\n  opts: ExtismPluginOptions = {},\n): Promise<Plugin> {\n  opts = { ...opts };\n  opts.useWasi ??= false;\n  opts.enableWasiOutput ??= opts.useWasi ? CAPABILITIES.extismStdoutEnvVarSet : false;\n  opts.functions = opts.functions || {};\n\n  // TODO(chrisdickinson): reset this to `CAPABILITIES.hasWorkerCapability` once we've fixed https://github.com/extism/js-sdk/issues/46.\n  opts.runInWorker ??= false;\n\n  opts.logger ??= console;\n  opts.logLevel ??= 'silent';\n  opts.fetch ??= fetch;\n\n  const [manifestOpts, names, moduleData] = await _toWasmModuleData(\n    await Promise.resolve(manifest),\n    opts.fetch ?? fetch,\n  );\n\n  opts.allowedPaths = opts.allowedPaths || manifestOpts.allowedPaths || {};\n  opts.allowedHosts = opts.allowedHosts || manifestOpts.allowedHosts || [];\n  opts.config = opts.config || manifestOpts.config || {};\n  opts.memory = opts.memory || manifestOpts.memory || {};\n  opts.timeoutMs = opts.timeoutMs || manifestOpts.timeoutMs || null;\n  opts.nodeWorkerArgs = Object.assign(\n    {\n      name: 'extism plugin',\n      execArgv: ['--disable-warning=ExperimentalWarning'],\n    },\n    opts.nodeWorkerArgs || {},\n  );\n\n  if (opts.allowedHosts.length && !opts.runInWorker) {\n    if (!(WebAssembly as any).Suspending) {\n      throw new TypeError(\n        '\"allowedHosts\" requires \"runInWorker: true\". HTTP functions are only available to plugins running in a worker.',\n      );\n    }\n  }\n\n  if (opts.timeoutMs && !opts.runInWorker) {\n    throw new TypeError(\n      '\"timeout\" requires \"runInWorker: true\". Call timeouts are only available to plugins running in a worker.',\n    );\n  }\n\n  if (opts.runInWorker && !CAPABILITIES.hasWorkerCapability) {\n    throw new Error(\n      'Cannot enable off-thread wasm; current context is not `crossOriginIsolated` (see https://mdn.io/crossOriginIsolated)',\n    );\n  }\n\n  for (const guest in opts.allowedPaths) {\n    const host = opts.allowedPaths[guest];\n\n    if (host.startsWith('ro:')) {\n      throw new Error(`Readonly dirs are not supported: ${host}`);\n    }\n  }\n\n  const ic: InternalConfig = {\n    allowedHosts: opts.allowedHosts as [],\n    allowedPaths: opts.allowedPaths,\n    functions: opts.functions,\n    fetch: opts.fetch || fetch,\n    wasiEnabled: opts.useWasi,\n    logger: opts.logger,\n    logLevel: logLevelToPriority(opts.logLevel || 'silent'),\n    config: opts.config,\n    enableWasiOutput: opts.enableWasiOutput,\n    sharedArrayBufferSize: Number(opts.sharedArrayBufferSize) || 1 << 16,\n    timeoutMs: opts.timeoutMs,\n    memory: opts.memory,\n    allowHttpResponseHeaders: !!opts.allowHttpResponseHeaders,\n    nodeWorkerArgs: opts.nodeWorkerArgs || {},\n  };\n\n  return (opts.runInWorker ? _createBackgroundPlugin : _createForegroundPlugin)(ic, names, moduleData);\n}\n\nexport { createPlugin as newPlugin };\n\nexport default createPlugin;\n"],
  "mappings": "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",
  "names": ["expand", "WebAssembly", "path", "block", "idx", "_a", "start", "final", "i", "acc", "ext", "_hasMagic", "ext", "qmark", "star", "expand", "regExpEscape", "open", "fetch", "module", "instance"]
}
